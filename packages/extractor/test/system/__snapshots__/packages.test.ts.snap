// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`can get EPD from "execa" package 1`] = `
Object {
  "docs": Object {
    "modules": Array [
      Object {
        "isMain": false,
        "kind": "module",
        "location": Object {
          "filePath": "index.d.ts",
        },
        "mainExport": null,
        "name": "index",
        "namedExports": Array [
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "StdioOption",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "CommonOptions",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).CommonOptions",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "Options",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).Options",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "SyncOptions",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).SyncOptions",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "NodeOptions",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).NodeOptions",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaReturnBase",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaReturnBase",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaSyncReturnValue",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaSyncReturnValue",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaReturnValue",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaReturnValue",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaSyncError",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaSyncError",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaError",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaError",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "KillOptions",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).KillOptions",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaChildPromise",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaChildPromise",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "ExecaChildProcess",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).ExecaChildProcess",
            },
          },
        ],
        "path": "/",
        "tsdoc": null,
      },
    ],
    "typeIndex": Object {
      "(index).CommonOptions": Object {
        "kind": "interface",
        "name": "CommonOptions",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "cleanup",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "preferLocal",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "localDir",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "execPath",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "buffer",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdin",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "reject",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stripFinalNewline",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "extendEnv",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "cwd",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "env",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
                "nodeText": "interface ProcessEnv extends Dict<string> {}",
                "typeText": "ProcessEnv",
              },
              "reason": "We do not support extracting from dependencies.",
            },
          },
          Object {
            "kind": "prop",
            "name": "argv0",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdio",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"pipe\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"ignore\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"inherit\\"",
                },
                Object {
                  "args": Array [
                    Object {
                      "kind": "typeIndexRef",
                      "link": "(index).StdioOption",
                    },
                  ],
                  "kind": "generic_instance",
                  "raw": Object {
                    "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "typeText": "readonly StdioOption[]",
                  },
                  "target": Object {
                    "kind": "standard_library",
                    "location": Object {
                      "modulePath": "typescript/lib/lib.es5.d.ts",
                    },
                    "name": "ReadonlyArray",
                    "raw": Object {
                      "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "typeText": "readonly T[]",
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "serialization",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"json\\" | \\"advanced\\"",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"json\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"advanced\\"",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "detached",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "uid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "gid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "shell",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | boolean",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "false",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "true",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "encoding",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "EncodingType",
                "nodeText": "EncodingType",
                "typeText": "EncodingType",
              },
              "reason": "This kind of type is not supported: \\"EncodingType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "timeout",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "maxBuffer",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "killSignal",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | number",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "primitive",
                  "type": "number",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsVerbatimArguments",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsHide",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface CommonOptions<EncodingType> {
		/**
		Kill the spawned process when the parent process exits unless either:
			- the spawned process is [\`detached\`](https://nodejs.org/api/child_process.html#child_process_options_detached)
			- the parent process is terminated abruptly, for example, with \`SIGKILL\` as opposed to \`SIGTERM\` or a normal exit

		@default true
		*/
		readonly cleanup?: boolean;

		/**
		Prefer locally installed binaries when looking for a binary to execute.

		If you \`$ npm install foo\`, you can then \`execa('foo')\`.

		@default false
		*/
		readonly preferLocal?: boolean;

		/**
		Preferred path to find locally installed binaries in (use with \`preferLocal\`).

		@default process.cwd()
		*/
		readonly localDir?: string;

		/**
		Path to the Node.js executable to use in child processes.

		This can be either an absolute path or a path relative to the \`cwd\` option.

		Requires \`preferLocal\` to be \`true\`.

		For example, this can be used together with [\`get-node\`](https://github.com/ehmicky/get-node) to run a specific Node.js version in a child process.

		@default process.execPath
		*/
		readonly execPath?: string;

		/**
		Buffer the output from the spawned process. When set to \`false\`, you must read the output of \`stdout\` and \`stderr\` (or \`all\` if the \`all\` option is \`true\`). Otherwise the returned promise will not be resolved/rejected.

		If the spawned process fails, \`error.stdout\`, \`error.stderr\`, and \`error.all\` will contain the buffered data.

		@default true
		*/
		readonly buffer?: boolean;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdin?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdout?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stderr?: StdioOption;

		/**
		Setting this to \`false\` resolves the promise with the error instead of rejecting it.

		@default true
		*/
		readonly reject?: boolean;

		/**
		Add an \`.all\` property on the promise and the resolved value. The property contains the output of the process with \`stdout\` and \`stderr\` interleaved.

		@default false
		*/
		readonly all?: boolean;

		/**
		Strip the final [newline character](https://en.wikipedia.org/wiki/Newline) from the output.

		@default true
		*/
		readonly stripFinalNewline?: boolean;

		/**
		Set to \`false\` if you don't want to extend the environment variables when providing the \`env\` property.

		@default true
		*/
		readonly extendEnv?: boolean;

		/**
		Current working directory of the child process.

		@default process.cwd()
		*/
		readonly cwd?: string;

		/**
		Environment key-value pairs. Extends automatically from \`process.env\`. Set \`extendEnv\` to \`false\` if you don't want this.

		@default process.env
		*/
		readonly env?: NodeJS.ProcessEnv;

		/**
		Explicitly set the value of \`argv[0]\` sent to the child process. This will be set to \`command\` or \`file\` if not specified.
		*/
		readonly argv0?: string;

		/**
		Child's [stdio](https://nodejs.org/api/child_process.html#child_process_options_stdio) configuration.

		@default 'pipe'
		*/
		readonly stdio?: 'pipe' | 'ignore' | 'inherit' | readonly StdioOption[];

		/**
		Specify the kind of serialization used for sending messages between processes when using the \`stdio: 'ipc'\` option or \`execa.node()\`:
			- \`json\`: Uses \`JSON.stringify()\` and \`JSON.parse()\`.
			- \`advanced\`: Uses [\`v8.serialize()\`](https://nodejs.org/api/v8.html#v8_v8_serialize_value)

		Requires Node.js \`13.2.0\` or later.

		[More info.](https://nodejs.org/api/child_process.html#child_process_advanced_serialization)

		@default 'json'
		*/
		readonly serialization?: 'json' | 'advanced';

		/**
		Prepare child to run independently of its parent process. Specific behavior [depends on the platform](https://nodejs.org/api/child_process.html#child_process_options_detached).

		@default false
		*/
		readonly detached?: boolean;

		/**
		Sets the user identity of the process.
		*/
		readonly uid?: number;

		/**
		Sets the group identity of the process.
		*/
		readonly gid?: number;

		/**
		If \`true\`, runs \`command\` inside of a shell. Uses \`/bin/sh\` on UNIX and \`cmd.exe\` on Windows. A different shell can be specified as a string. The shell should understand the \`-c\` switch on UNIX or \`/d /s /c\` on Windows.

		We recommend against using this option since it is:
		- not cross-platform, encouraging shell-specific syntax.
		- slower, because of the additional shell interpretation.
		- unsafe, potentially allowing command injection.

		@default false
		*/
		readonly shell?: boolean | string;

		/**
		Specify the character encoding used to decode the \`stdout\` and \`stderr\` output. If set to \`null\`, then \`stdout\` and \`stderr\` will be a \`Buffer\` instead of a string.

		@default 'utf8'
		*/
		readonly encoding?: EncodingType;

		/**
		If \`timeout\` is greater than \`0\`, the parent will send the signal identified by the \`killSignal\` property (the default is \`SIGTERM\`) if the child runs longer than \`timeout\` milliseconds.

		@default 0
		*/
		readonly timeout?: number;

		/**
		Largest amount of data in bytes allowed on \`stdout\` or \`stderr\`. Default: 100 MB.

		@default 100_000_000
		*/
		readonly maxBuffer?: number;

		/**
		Signal value to be used when the spawned process will be killed.

		@default 'SIGTERM'
		*/
		readonly killSignal?: string | number;

		/**
		If \`true\`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to \`true\` automatically when the \`shell\` option is \`true\`.

		@default false
		*/
		readonly windowsVerbatimArguments?: boolean;

		/**
		On Windows, do not create a new console window. Please note this also prevents \`CTRL-C\` [from working](https://github.com/nodejs/node/issues/29837) on Windows.

		@default true
		*/
		readonly windowsHide?: boolean;
	}",
          "nodeText": "interface CommonOptions<EncodingType> {
		/**
		Kill the spawned process when the parent process exits unless either:
			- the spawned process is [\`detached\`](https://nodejs.org/api/child_process.html#child_process_options_detached)
			- the parent process is terminated abruptly, for example, with \`SIGKILL\` as opposed to \`SIGTERM\` or a normal exit

		@default true
		*/
		readonly cleanup?: boolean;

		/**
		Prefer locally installed binaries when looking for a binary to execute.

		If you \`$ npm install foo\`, you can then \`execa('foo')\`.

		@default false
		*/
		readonly preferLocal?: boolean;

		/**
		Preferred path to find locally installed binaries in (use with \`preferLocal\`).

		@default process.cwd()
		*/
		readonly localDir?: string;

		/**
		Path to the Node.js executable to use in child processes.

		This can be either an absolute path or a path relative to the \`cwd\` option.

		Requires \`preferLocal\` to be \`true\`.

		For example, this can be used together with [\`get-node\`](https://github.com/ehmicky/get-node) to run a specific Node.js version in a child process.

		@default process.execPath
		*/
		readonly execPath?: string;

		/**
		Buffer the output from the spawned process. When set to \`false\`, you must read the output of \`stdout\` and \`stderr\` (or \`all\` if the \`all\` option is \`true\`). Otherwise the returned promise will not be resolved/rejected.

		If the spawned process fails, \`error.stdout\`, \`error.stderr\`, and \`error.all\` will contain the buffered data.

		@default true
		*/
		readonly buffer?: boolean;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdin?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdout?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stderr?: StdioOption;

		/**
		Setting this to \`false\` resolves the promise with the error instead of rejecting it.

		@default true
		*/
		readonly reject?: boolean;

		/**
		Add an \`.all\` property on the promise and the resolved value. The property contains the output of the process with \`stdout\` and \`stderr\` interleaved.

		@default false
		*/
		readonly all?: boolean;

		/**
		Strip the final [newline character](https://en.wikipedia.org/wiki/Newline) from the output.

		@default true
		*/
		readonly stripFinalNewline?: boolean;

		/**
		Set to \`false\` if you don't want to extend the environment variables when providing the \`env\` property.

		@default true
		*/
		readonly extendEnv?: boolean;

		/**
		Current working directory of the child process.

		@default process.cwd()
		*/
		readonly cwd?: string;

		/**
		Environment key-value pairs. Extends automatically from \`process.env\`. Set \`extendEnv\` to \`false\` if you don't want this.

		@default process.env
		*/
		readonly env?: NodeJS.ProcessEnv;

		/**
		Explicitly set the value of \`argv[0]\` sent to the child process. This will be set to \`command\` or \`file\` if not specified.
		*/
		readonly argv0?: string;

		/**
		Child's [stdio](https://nodejs.org/api/child_process.html#child_process_options_stdio) configuration.

		@default 'pipe'
		*/
		readonly stdio?: 'pipe' | 'ignore' | 'inherit' | readonly StdioOption[];

		/**
		Specify the kind of serialization used for sending messages between processes when using the \`stdio: 'ipc'\` option or \`execa.node()\`:
			- \`json\`: Uses \`JSON.stringify()\` and \`JSON.parse()\`.
			- \`advanced\`: Uses [\`v8.serialize()\`](https://nodejs.org/api/v8.html#v8_v8_serialize_value)

		Requires Node.js \`13.2.0\` or later.

		[More info.](https://nodejs.org/api/child_process.html#child_process_advanced_serialization)

		@default 'json'
		*/
		readonly serialization?: 'json' | 'advanced';

		/**
		Prepare child to run independently of its parent process. Specific behavior [depends on the platform](https://nodejs.org/api/child_process.html#child_process_options_detached).

		@default false
		*/
		readonly detached?: boolean;

		/**
		Sets the user identity of the process.
		*/
		readonly uid?: number;

		/**
		Sets the group identity of the process.
		*/
		readonly gid?: number;

		/**
		If \`true\`, runs \`command\` inside of a shell. Uses \`/bin/sh\` on UNIX and \`cmd.exe\` on Windows. A different shell can be specified as a string. The shell should understand the \`-c\` switch on UNIX or \`/d /s /c\` on Windows.

		We recommend against using this option since it is:
		- not cross-platform, encouraging shell-specific syntax.
		- slower, because of the additional shell interpretation.
		- unsafe, potentially allowing command injection.

		@default false
		*/
		readonly shell?: boolean | string;

		/**
		Specify the character encoding used to decode the \`stdout\` and \`stderr\` output. If set to \`null\`, then \`stdout\` and \`stderr\` will be a \`Buffer\` instead of a string.

		@default 'utf8'
		*/
		readonly encoding?: EncodingType;

		/**
		If \`timeout\` is greater than \`0\`, the parent will send the signal identified by the \`killSignal\` property (the default is \`SIGTERM\`) if the child runs longer than \`timeout\` milliseconds.

		@default 0
		*/
		readonly timeout?: number;

		/**
		Largest amount of data in bytes allowed on \`stdout\` or \`stderr\`. Default: 100 MB.

		@default 100_000_000
		*/
		readonly maxBuffer?: number;

		/**
		Signal value to be used when the spawned process will be killed.

		@default 'SIGTERM'
		*/
		readonly killSignal?: string | number;

		/**
		If \`true\`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to \`true\` automatically when the \`shell\` option is \`true\`.

		@default false
		*/
		readonly windowsVerbatimArguments?: boolean;

		/**
		On Windows, do not create a new console window. Please note this also prevents \`CTRL-C\` [from working](https://github.com/nodejs/node/issues/29837) on Windows.

		@default true
		*/
		readonly windowsHide?: boolean;
	}",
          "typeText": "CommonOptions<EncodingType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": null,
            "name": "EncodingType",
            "raw": Object {
              "nodeFullText": "EncodingType",
              "nodeText": "EncodingType",
              "typeText": "EncodingType",
            },
          },
        ],
      },
      "(index).ExecaChildProcess": Object {
        "kind": "alias",
        "name": "ExecaChildProcess",
        "raw": Object {
          "nodeFullText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
          "nodeText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
          "typeText": "ExecaChildProcess<StdoutErrorType>",
        },
        "tsdoc": null,
        "type": Object {
          "kind": "intersection",
          "raw": Object {
            "nodeFullText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
            "nodeText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
            "typeText": "ExecaChildProcess<StdoutErrorType>",
          },
          "types": Array [
            Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "interface ChildProcess extends events.EventEmitter {
        stdin: Writable | null;
        stdout: Readable | null;
        stderr: Readable | null;
        readonly channel?: Pipe | null;
        readonly stdio: [
            Writable | null, // stdin
            Readable | null, // stdout
            Readable | null, // stderr
            Readable | Writable | null | undefined, // extra
            Readable | Writable | null | undefined // extra
        ];
        readonly killed: boolean;
        readonly pid: number;
        readonly connected: boolean;
        readonly exitCode: number | null;
        readonly signalCode: NodeJS.Signals | null;
        readonly spawnargs: string[];
        readonly spawnfile: string;
        kill(signal?: NodeJS.Signals | number): boolean;
        send(message: Serializable, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, options?: MessageOptions, callback?: (error: Error | null) => void): boolean;
        disconnect(): void;
        unref(): void;
        ref(): void;

        /**
         * events.EventEmitter
         * 1. close
         * 2. disconnect
         * 3. error
         * 4. exit
         * 5. message
         */

        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        addListener(event: \\"disconnect\\", listener: () => void): this;
        addListener(event: \\"error\\", listener: (err: Error) => void): this;
        addListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: \\"close\\", code: number, signal: NodeJS.Signals): boolean;
        emit(event: \\"disconnect\\"): boolean;
        emit(event: \\"error\\", err: Error): boolean;
        emit(event: \\"exit\\", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: \\"message\\", message: Serializable, sendHandle: SendHandle): boolean;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        on(event: \\"disconnect\\", listener: () => void): this;
        on(event: \\"error\\", listener: (err: Error) => void): this;
        on(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        once(event: \\"disconnect\\", listener: () => void): this;
        once(event: \\"error\\", listener: (err: Error) => void): this;
        once(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependListener(event: \\"disconnect\\", listener: () => void): this;
        prependListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependOnceListener(event: \\"disconnect\\", listener: () => void): this;
        prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependOnceListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependOnceListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
    }",
                "nodeText": "interface ChildProcess extends events.EventEmitter {
        stdin: Writable | null;
        stdout: Readable | null;
        stderr: Readable | null;
        readonly channel?: Pipe | null;
        readonly stdio: [
            Writable | null, // stdin
            Readable | null, // stdout
            Readable | null, // stderr
            Readable | Writable | null | undefined, // extra
            Readable | Writable | null | undefined // extra
        ];
        readonly killed: boolean;
        readonly pid: number;
        readonly connected: boolean;
        readonly exitCode: number | null;
        readonly signalCode: NodeJS.Signals | null;
        readonly spawnargs: string[];
        readonly spawnfile: string;
        kill(signal?: NodeJS.Signals | number): boolean;
        send(message: Serializable, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, options?: MessageOptions, callback?: (error: Error | null) => void): boolean;
        disconnect(): void;
        unref(): void;
        ref(): void;

        /**
         * events.EventEmitter
         * 1. close
         * 2. disconnect
         * 3. error
         * 4. exit
         * 5. message
         */

        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        addListener(event: \\"disconnect\\", listener: () => void): this;
        addListener(event: \\"error\\", listener: (err: Error) => void): this;
        addListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: \\"close\\", code: number, signal: NodeJS.Signals): boolean;
        emit(event: \\"disconnect\\"): boolean;
        emit(event: \\"error\\", err: Error): boolean;
        emit(event: \\"exit\\", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: \\"message\\", message: Serializable, sendHandle: SendHandle): boolean;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        on(event: \\"disconnect\\", listener: () => void): this;
        on(event: \\"error\\", listener: (err: Error) => void): this;
        on(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        once(event: \\"disconnect\\", listener: () => void): this;
        once(event: \\"error\\", listener: (err: Error) => void): this;
        once(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependListener(event: \\"disconnect\\", listener: () => void): this;
        prependListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependOnceListener(event: \\"disconnect\\", listener: () => void): this;
        prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependOnceListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependOnceListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
    }",
                "typeText": "ChildProcess",
              },
              "reason": "We do not support extracting from dependencies.",
            },
            Object {
              "args": Array [
                Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "StdoutErrorType = string",
                    "nodeText": "StdoutErrorType = string",
                    "typeText": "StdoutErrorType",
                  },
                  "reason": "This kind of type is not supported: \\"StdoutErrorType\\"",
                },
              ],
              "kind": "generic_instance",
              "raw": Object {
                "nodeFullText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
                "nodeText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
                "typeText": "ExecaChildPromise<StdoutErrorType>",
              },
              "target": Object {
                "kind": "typeIndexRef",
                "link": "(index).ExecaChildPromise",
              },
            },
            Object {
              "args": Array [
                Object {
                  "args": Array [
                    Object {
                      "kind": "unsupported",
                      "raw": Object {
                        "nodeFullText": "StdoutErrorType = string",
                        "nodeText": "StdoutErrorType = string",
                        "typeText": "StdoutErrorType",
                      },
                      "reason": "This kind of type is not supported: \\"StdoutErrorType\\"",
                    },
                  ],
                  "kind": "generic_instance",
                  "raw": Object {
                    "nodeFullText": "/**
	Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes
	*/
	interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                    "nodeText": "interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                    "typeText": "ExecaReturnValue<StdoutErrorType>",
                  },
                  "target": Object {
                    "kind": "typeIndexRef",
                    "link": "(index).ExecaReturnValue",
                  },
                },
              ],
              "kind": "generic_instance",
              "raw": Object {
                "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                "typeText": "Promise<ExecaReturnValue<StdoutErrorType>>",
              },
              "target": Object {
                "kind": "standard_library",
                "location": Object {
                  "modulePath": "typescript/lib/lib.es5.d.ts",
                },
                "name": "Promise",
                "raw": Object {
                  "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                  "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                  "typeText": "Promise<T>",
                },
              },
            },
          ],
        },
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "StdoutErrorType",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        ],
      },
      "(index).ExecaChildPromise": Object {
        "kind": "interface",
        "name": "ExecaChildPromise",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "catch",
            "type": Object {
              "hasProps": false,
              "isOverloaded": false,
              "kind": "callable",
              "props": Array [],
              "raw": Object {
                "nodeFullText": "catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;",
                "nodeText": "catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;",
                "typeText": "<ResultType = never>(onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>) => Promise<ResultType | ExecaReturnValue<...>>",
              },
              "sigs": Array [
                Object {
                  "kind": "sig",
                  "params": Array [
                    Object {
                      "kind": "sigParam",
                      "name": "onRejected",
                      "type": Object {
                        "hasProps": false,
                        "isOverloaded": false,
                        "kind": "callable",
                        "props": Array [],
                        "raw": Object {
                          "nodeFullText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                          "nodeText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                          "typeText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                        },
                        "sigs": Array [
                          Object {
                            "kind": "sig",
                            "params": Array [
                              Object {
                                "kind": "sigParam",
                                "name": "reason",
                                "type": Object {
                                  "args": Array [
                                    Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "StdoutErrorType",
                                        "nodeText": "StdoutErrorType",
                                        "typeText": "StdoutErrorType",
                                      },
                                      "reason": "This kind of type is not supported: \\"StdoutErrorType\\"",
                                    },
                                  ],
                                  "kind": "generic_instance",
                                  "raw": Object {
                                    "nodeFullText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                                    "nodeText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                                    "typeText": "ExecaError<StdoutErrorType>",
                                  },
                                  "target": Object {
                                    "kind": "typeIndexRef",
                                    "link": "(index).ExecaError",
                                  },
                                },
                              },
                            ],
                            "return": Object {
                              "discriminantProperties": null,
                              "isDiscriminated": false,
                              "kind": "union",
                              "raw": Object {
                                "nodeFullText": "",
                                "nodeText": "",
                                "typeText": "ResultType | PromiseLike<ResultType>",
                              },
                              "types": Array [
                                Object {
                                  "kind": "unsupported",
                                  "raw": Object {
                                    "nodeFullText": "ResultType = never",
                                    "nodeText": "ResultType = never",
                                    "typeText": "ResultType",
                                  },
                                  "reason": "This kind of type is not supported: \\"ResultType\\"",
                                },
                                Object {
                                  "args": Array [
                                    Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "ResultType = never",
                                        "nodeText": "ResultType = never",
                                        "typeText": "ResultType",
                                      },
                                      "reason": "This kind of type is not supported: \\"ResultType\\"",
                                    },
                                  ],
                                  "kind": "generic_instance",
                                  "raw": Object {
                                    "nodeFullText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                    "nodeText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                    "typeText": "PromiseLike<ResultType>",
                                  },
                                  "target": Object {
                                    "kind": "standard_library",
                                    "location": Object {
                                      "modulePath": "typescript/lib/lib.es5.d.ts",
                                    },
                                    "name": "PromiseLike",
                                    "raw": Object {
                                      "nodeFullText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                      "nodeText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                      "typeText": "PromiseLike<T>",
                                    },
                                  },
                                },
                              ],
                            },
                          },
                        ],
                      },
                    },
                  ],
                  "return": Object {
                    "args": Array [
                      Object {
                        "discriminantProperties": null,
                        "isDiscriminated": false,
                        "kind": "union",
                        "raw": Object {
                          "nodeFullText": "",
                          "nodeText": "",
                          "typeText": "ResultType | ExecaReturnValue<StdoutErrorType>",
                        },
                        "types": Array [
                          Object {
                            "kind": "unsupported",
                            "raw": Object {
                              "nodeFullText": "ResultType = never",
                              "nodeText": "ResultType = never",
                              "typeText": "ResultType",
                            },
                            "reason": "This kind of type is not supported: \\"ResultType\\"",
                          },
                          Object {
                            "args": Array [
                              Object {
                                "kind": "unsupported",
                                "raw": Object {
                                  "nodeFullText": "StdoutErrorType",
                                  "nodeText": "StdoutErrorType",
                                  "typeText": "StdoutErrorType",
                                },
                                "reason": "This kind of type is not supported: \\"StdoutErrorType\\"",
                              },
                            ],
                            "kind": "generic_instance",
                            "raw": Object {
                              "nodeFullText": "/**
	Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes
	*/
	interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                              "nodeText": "interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                              "typeText": "ExecaReturnValue<StdoutErrorType>",
                            },
                            "target": Object {
                              "kind": "typeIndexRef",
                              "link": "(index).ExecaReturnValue",
                            },
                          },
                        ],
                      },
                    ],
                    "kind": "generic_instance",
                    "raw": Object {
                      "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                      "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                      "typeText": "Promise<ResultType | ExecaReturnValue<StdoutErrorType>>",
                    },
                    "target": Object {
                      "kind": "standard_library",
                      "location": Object {
                        "modulePath": "typescript/lib/lib.es5.d.ts",
                      },
                      "name": "Promise",
                      "raw": Object {
                        "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                        "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                        "typeText": "Promise<T>",
                      },
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "kill",
            "type": Object {
              "hasProps": false,
              "isOverloaded": false,
              "kind": "callable",
              "props": Array [],
              "raw": Object {
                "nodeFullText": "/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;",
                "nodeText": "kill(signal?: string, options?: execa.KillOptions): void;",
                "typeText": "(signal?: string, options?: KillOptions) => void",
              },
              "sigs": Array [
                Object {
                  "kind": "sig",
                  "params": Array [
                    Object {
                      "kind": "sigParam",
                      "name": "signal",
                      "type": Object {
                        "kind": "primitive",
                        "type": "string",
                      },
                    },
                    Object {
                      "kind": "sigParam",
                      "name": "options",
                      "type": Object {
                        "kind": "typeIndexRef",
                        "link": "(index).KillOptions",
                      },
                    },
                  ],
                  "return": Object {
                    "kind": "primitive",
                    "type": "void",
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "cancel",
            "type": Object {
              "hasProps": false,
              "isOverloaded": false,
              "kind": "callable",
              "props": Array [],
              "raw": Object {
                "nodeFullText": "/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;",
                "nodeText": "cancel(): void;",
                "typeText": "() => void",
              },
              "sigs": Array [
                Object {
                  "kind": "sig",
                  "params": Array [],
                  "return": Object {
                    "kind": "primitive",
                    "type": "void",
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                "typeText": "Readable",
              },
              "reason": "We do not support extracting from dependencies.",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
          "nodeText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
          "typeText": "ExecaChildPromise<StdoutErrorType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": null,
            "name": "StdoutErrorType",
            "raw": Object {
              "nodeFullText": "StdoutErrorType",
              "nodeText": "StdoutErrorType",
              "typeText": "StdoutErrorType",
            },
          },
        ],
      },
      "(index).ExecaError": Object {
        "kind": "interface",
        "name": "ExecaError",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutErrorType = string",
                "nodeText": "StdoutErrorType = string",
                "typeText": "StdoutErrorType",
              },
              "reason": "This kind of type is not supported: \\"StdoutErrorType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "isCanceled",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "message",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "shortMessage",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "originalMessage",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "name",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "stack",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "command",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "exitCode",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "failed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "timedOut",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "killed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "signal",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "signalDescription",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
          "nodeText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
          "typeText": "ExecaError<StdoutErrorType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "StdoutErrorType",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        ],
      },
      "(index).ExecaReturnBase": Object {
        "kind": "interface",
        "name": "ExecaReturnBase",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "command",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "exitCode",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "failed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "timedOut",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "killed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "signal",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "signalDescription",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface ExecaReturnBase<StdoutStderrType> {
		/**
		The file and arguments that were run.
		*/
		command: string;

		/**
		The numeric exit code of the process that was run.
		*/
		exitCode: number;

		/**
		The output of the process on stdout.
		*/
		stdout: StdoutStderrType;

		/**
		The output of the process on stderr.
		*/
		stderr: StdoutStderrType;

		/**
		Whether the process failed to run.
		*/
		failed: boolean;

		/**
		Whether the process timed out.
		*/
		timedOut: boolean;

		/**
		Whether the process was killed.
		*/
		killed: boolean;

		/**
		The name of the signal that was used to terminate the process. For example, \`SIGFPE\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`.
		*/
		signal?: string;

		/**
		A human-friendly description of the signal that was used to terminate the process. For example, \`Floating point arithmetic error\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`. It is also \`undefined\` when the signal is very uncommon which should seldomly happen.
		*/
		signalDescription?: string;
	}",
          "nodeText": "interface ExecaReturnBase<StdoutStderrType> {
		/**
		The file and arguments that were run.
		*/
		command: string;

		/**
		The numeric exit code of the process that was run.
		*/
		exitCode: number;

		/**
		The output of the process on stdout.
		*/
		stdout: StdoutStderrType;

		/**
		The output of the process on stderr.
		*/
		stderr: StdoutStderrType;

		/**
		Whether the process failed to run.
		*/
		failed: boolean;

		/**
		Whether the process timed out.
		*/
		timedOut: boolean;

		/**
		Whether the process was killed.
		*/
		killed: boolean;

		/**
		The name of the signal that was used to terminate the process. For example, \`SIGFPE\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`.
		*/
		signal?: string;

		/**
		A human-friendly description of the signal that was used to terminate the process. For example, \`Floating point arithmetic error\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`. It is also \`undefined\` when the signal is very uncommon which should seldomly happen.
		*/
		signalDescription?: string;
	}",
          "typeText": "ExecaReturnBase<StdoutStderrType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": null,
            "name": "StdoutStderrType",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        ],
      },
      "(index).ExecaReturnValue": Object {
        "kind": "interface",
        "name": "ExecaReturnValue",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutErrorType = string",
                "nodeText": "StdoutErrorType = string",
                "typeText": "StdoutErrorType",
              },
              "reason": "This kind of type is not supported: \\"StdoutErrorType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "isCanceled",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "command",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "exitCode",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "failed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "timedOut",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "killed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "signal",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "signalDescription",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "/**
	Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes
	*/
	interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
          "nodeText": "interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
          "typeText": "ExecaReturnValue<StdoutErrorType>",
        },
        "tsdoc": Object {
          "customTags": Array [],
          "examples": Array [],
          "raw": "/**
	Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes
	*/",
          "summary": "Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes",
        },
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "StdoutErrorType",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        ],
      },
      "(index).ExecaSyncError": Object {
        "kind": "interface",
        "name": "ExecaSyncError",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "message",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "shortMessage",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "originalMessage",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "name",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "stack",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "command",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "exitCode",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "failed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "timedOut",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "killed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "signal",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "signalDescription",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface ExecaSyncError<StdoutErrorType = string>
		extends Error,
			ExecaReturnBase<StdoutErrorType> {
		/**
		Error message when the child process failed to run. In addition to the underlying error message, it also contains some information related to why the child process errored.

		The child process stderr then stdout are appended to the end, separated with newlines and not interleaved.
		*/
		message: string;

		/**
		This is the same as the \`message\` property except it does not include the child process stdout/stderr.
		*/
		shortMessage: string;

		/**
		Original error message. This is the same as the \`message\` property except it includes neither the child process stdout/stderr nor some additional information added by Execa.

		This is \`undefined\` unless the child process exited due to an \`error\` event or a timeout.
		*/
		originalMessage?: string;
	}",
          "nodeText": "interface ExecaSyncError<StdoutErrorType = string>
		extends Error,
			ExecaReturnBase<StdoutErrorType> {
		/**
		Error message when the child process failed to run. In addition to the underlying error message, it also contains some information related to why the child process errored.

		The child process stderr then stdout are appended to the end, separated with newlines and not interleaved.
		*/
		message: string;

		/**
		This is the same as the \`message\` property except it does not include the child process stdout/stderr.
		*/
		shortMessage: string;

		/**
		Original error message. This is the same as the \`message\` property except it includes neither the child process stdout/stderr nor some additional information added by Execa.

		This is \`undefined\` unless the child process exited due to an \`error\` event or a timeout.
		*/
		originalMessage?: string;
	}",
          "typeText": "ExecaSyncError<StdoutErrorType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "StdoutErrorType",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        ],
      },
      "(index).ExecaSyncReturnValue": Object {
        "kind": "interface",
        "name": "ExecaSyncReturnValue",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "command",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "exitCode",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "StdoutStderrType",
                "nodeText": "StdoutStderrType",
                "typeText": "StdoutStderrType",
              },
              "reason": "This kind of type is not supported: \\"StdoutStderrType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "failed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "timedOut",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "killed",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "signal",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "signalDescription",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface ExecaSyncReturnValue<StdoutErrorType = string>
		extends ExecaReturnBase<StdoutErrorType> {
	}",
          "nodeText": "interface ExecaSyncReturnValue<StdoutErrorType = string>
		extends ExecaReturnBase<StdoutErrorType> {
	}",
          "typeText": "ExecaSyncReturnValue<StdoutErrorType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "StdoutErrorType",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        ],
      },
      "(index).KillOptions": Object {
        "kind": "interface",
        "name": "KillOptions",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "forceKillAfterTimeout",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "number | false",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "number",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "false",
                },
              ],
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface KillOptions {
		/**
		Milliseconds to wait for the child process to terminate before sending \`SIGKILL\`.

		Can be disabled with \`false\`.

		@default 5000
		*/
		forceKillAfterTimeout?: number | false;
	}",
          "nodeText": "interface KillOptions {
		/**
		Milliseconds to wait for the child process to terminate before sending \`SIGKILL\`.

		Can be disabled with \`false\`.

		@default 5000
		*/
		forceKillAfterTimeout?: number | false;
	}",
          "typeText": "KillOptions",
        },
        "tsdoc": null,
        "typeParameters": Array [],
      },
      "(index).NodeOptions": Object {
        "kind": "interface",
        "name": "NodeOptions",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "nodePath",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "nodeOptions",
            "type": Object {
              "innerType": Object {
                "kind": "primitive",
                "type": "string",
              },
              "kind": "array",
            },
          },
          Object {
            "kind": "prop",
            "name": "input",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | Buffer | Readable",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "/**
 * Raw data is stored in instances of the Buffer class.
 * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
 * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
 */
declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                    "nodeText": "declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                    "typeText": "Buffer",
                  },
                  "reason": "We do not support extracting from dependencies.",
                },
                Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                    "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                    "typeText": "Readable",
                  },
                  "reason": "We do not support extracting from dependencies.",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "cleanup",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "preferLocal",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "localDir",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "execPath",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "buffer",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdin",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "reject",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stripFinalNewline",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "extendEnv",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "cwd",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "env",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
                "nodeText": "interface ProcessEnv extends Dict<string> {}",
                "typeText": "ProcessEnv",
              },
              "reason": "We do not support extracting from dependencies.",
            },
          },
          Object {
            "kind": "prop",
            "name": "argv0",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdio",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"pipe\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"ignore\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"inherit\\"",
                },
                Object {
                  "args": Array [
                    Object {
                      "kind": "typeIndexRef",
                      "link": "(index).StdioOption",
                    },
                  ],
                  "kind": "generic_instance",
                  "raw": Object {
                    "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "typeText": "readonly StdioOption[]",
                  },
                  "target": Object {
                    "kind": "standard_library",
                    "location": Object {
                      "modulePath": "typescript/lib/lib.es5.d.ts",
                    },
                    "name": "ReadonlyArray",
                    "raw": Object {
                      "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "typeText": "readonly T[]",
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "serialization",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"json\\" | \\"advanced\\"",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"json\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"advanced\\"",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "detached",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "uid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "gid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "shell",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | boolean",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "false",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "true",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "encoding",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "EncodingType",
                "nodeText": "EncodingType",
                "typeText": "EncodingType",
              },
              "reason": "This kind of type is not supported: \\"EncodingType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "timeout",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "maxBuffer",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "killSignal",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | number",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "primitive",
                  "type": "number",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsVerbatimArguments",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsHide",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface NodeOptions<EncodingType = string> extends Options<EncodingType> {
		/**
		The Node.js executable to use.

		@default process.execPath
		*/
		readonly nodePath?: string;

		/**
		List of [CLI options](https://nodejs.org/api/cli.html#cli_options) passed to the Node.js executable.

		@default process.execArgv
		*/
		readonly nodeOptions?: string[];
	}",
          "nodeText": "interface NodeOptions<EncodingType = string> extends Options<EncodingType> {
		/**
		The Node.js executable to use.

		@default process.execPath
		*/
		readonly nodePath?: string;

		/**
		List of [CLI options](https://nodejs.org/api/cli.html#cli_options) passed to the Node.js executable.

		@default process.execArgv
		*/
		readonly nodeOptions?: string[];
	}",
          "typeText": "NodeOptions<EncodingType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "EncodingType",
            "raw": Object {
              "nodeFullText": "EncodingType = string",
              "nodeText": "EncodingType = string",
              "typeText": "EncodingType",
            },
          },
        ],
      },
      "(index).Options": Object {
        "kind": "interface",
        "name": "Options",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "input",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | Buffer | Readable",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "/**
 * Raw data is stored in instances of the Buffer class.
 * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
 * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
 */
declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                    "nodeText": "declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                    "typeText": "Buffer",
                  },
                  "reason": "We do not support extracting from dependencies.",
                },
                Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                    "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                    "typeText": "Readable",
                  },
                  "reason": "We do not support extracting from dependencies.",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "cleanup",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "preferLocal",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "localDir",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "execPath",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "buffer",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdin",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "reject",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stripFinalNewline",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "extendEnv",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "cwd",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "env",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
                "nodeText": "interface ProcessEnv extends Dict<string> {}",
                "typeText": "ProcessEnv",
              },
              "reason": "We do not support extracting from dependencies.",
            },
          },
          Object {
            "kind": "prop",
            "name": "argv0",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdio",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"pipe\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"ignore\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"inherit\\"",
                },
                Object {
                  "args": Array [
                    Object {
                      "kind": "typeIndexRef",
                      "link": "(index).StdioOption",
                    },
                  ],
                  "kind": "generic_instance",
                  "raw": Object {
                    "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "typeText": "readonly StdioOption[]",
                  },
                  "target": Object {
                    "kind": "standard_library",
                    "location": Object {
                      "modulePath": "typescript/lib/lib.es5.d.ts",
                    },
                    "name": "ReadonlyArray",
                    "raw": Object {
                      "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "typeText": "readonly T[]",
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "serialization",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"json\\" | \\"advanced\\"",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"json\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"advanced\\"",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "detached",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "uid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "gid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "shell",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | boolean",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "false",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "true",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "encoding",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "EncodingType",
                "nodeText": "EncodingType",
                "typeText": "EncodingType",
              },
              "reason": "This kind of type is not supported: \\"EncodingType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "timeout",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "maxBuffer",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "killSignal",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | number",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "primitive",
                  "type": "number",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsVerbatimArguments",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsHide",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface Options<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer | ReadableStream;
	}",
          "nodeText": "interface Options<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer | ReadableStream;
	}",
          "typeText": "Options<EncodingType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "EncodingType",
            "raw": Object {
              "nodeFullText": "EncodingType = string",
              "nodeText": "EncodingType = string",
              "typeText": "EncodingType",
            },
          },
        ],
      },
      "(index).StdioOption": Object {
        "kind": "alias",
        "name": "StdioOption",
        "raw": Object {
          "nodeFullText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
          "nodeText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
          "typeText": "StdioOption",
        },
        "tsdoc": null,
        "type": Object {
          "discriminantProperties": null,
          "isDiscriminated": false,
          "kind": "union",
          "raw": Object {
            "nodeFullText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
            "nodeText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
            "typeText": "StdioOption",
          },
          "types": Array [
            Object {
              "kind": "primitive",
              "type": "number",
            },
            Object {
              "base": "string",
              "kind": "literal",
              "name": "\\"pipe\\"",
            },
            Object {
              "base": "string",
              "kind": "literal",
              "name": "\\"ipc\\"",
            },
            Object {
              "base": "string",
              "kind": "literal",
              "name": "\\"ignore\\"",
            },
            Object {
              "base": "string",
              "kind": "literal",
              "name": "\\"inherit\\"",
            },
            Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "class Stream extends internal {
            constructor(opts?: ReadableOptions);
        }",
                "nodeText": "class Stream extends internal {
            constructor(opts?: ReadableOptions);
        }",
                "typeText": "Stream",
              },
              "reason": "We do not support extracting from dependencies.",
            },
          ],
        },
        "typeParameters": Array [],
      },
      "(index).SyncOptions": Object {
        "kind": "interface",
        "name": "SyncOptions",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "input",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | Buffer",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "/**
 * Raw data is stored in instances of the Buffer class.
 * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
 * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
 */
declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                    "nodeText": "declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                    "typeText": "Buffer",
                  },
                  "reason": "We do not support extracting from dependencies.",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "cleanup",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "preferLocal",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "localDir",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "execPath",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "buffer",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdin",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdout",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "stderr",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(index).StdioOption",
            },
          },
          Object {
            "kind": "prop",
            "name": "reject",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "all",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "stripFinalNewline",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "extendEnv",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "cwd",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "env",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
                "nodeText": "interface ProcessEnv extends Dict<string> {}",
                "typeText": "ProcessEnv",
              },
              "reason": "We do not support extracting from dependencies.",
            },
          },
          Object {
            "kind": "prop",
            "name": "argv0",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "stdio",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"pipe\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"ignore\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"inherit\\"",
                },
                Object {
                  "args": Array [
                    Object {
                      "kind": "typeIndexRef",
                      "link": "(index).StdioOption",
                    },
                  ],
                  "kind": "generic_instance",
                  "raw": Object {
                    "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                    "typeText": "readonly StdioOption[]",
                  },
                  "target": Object {
                    "kind": "standard_library",
                    "location": Object {
                      "modulePath": "typescript/lib/lib.es5.d.ts",
                    },
                    "name": "ReadonlyArray",
                    "raw": Object {
                      "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                      "typeText": "readonly T[]",
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "serialization",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "\\"json\\" | \\"advanced\\"",
              },
              "types": Array [
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"json\\"",
                },
                Object {
                  "base": "string",
                  "kind": "literal",
                  "name": "\\"advanced\\"",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "detached",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "uid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "gid",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "shell",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | boolean",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "false",
                },
                Object {
                  "base": "boolean",
                  "kind": "literal",
                  "name": "true",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "encoding",
            "type": Object {
              "kind": "unsupported",
              "raw": Object {
                "nodeFullText": "EncodingType",
                "nodeText": "EncodingType",
                "typeText": "EncodingType",
              },
              "reason": "This kind of type is not supported: \\"EncodingType\\"",
            },
          },
          Object {
            "kind": "prop",
            "name": "timeout",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "maxBuffer",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
          Object {
            "kind": "prop",
            "name": "killSignal",
            "type": Object {
              "discriminantProperties": null,
              "isDiscriminated": false,
              "kind": "union",
              "raw": Object {
                "nodeFullText": "",
                "nodeText": "",
                "typeText": "string | number",
              },
              "types": Array [
                Object {
                  "kind": "primitive",
                  "type": "string",
                },
                Object {
                  "kind": "primitive",
                  "type": "number",
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsVerbatimArguments",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "windowsHide",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "interface SyncOptions<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer;
	}",
          "nodeText": "interface SyncOptions<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer;
	}",
          "typeText": "SyncOptions<EncodingType>",
        },
        "tsdoc": null,
        "typeParameters": Array [
          Object {
            "default": Object {
              "kind": "primitive",
              "type": "string",
            },
            "name": "EncodingType",
            "raw": Object {
              "nodeFullText": "EncodingType = string",
              "nodeText": "EncodingType = string",
              "typeText": "EncodingType",
            },
          },
        ],
      },
    },
  },
  "metadata": Object {
    "_id": "execa",
    "_rev": "83-7f881b5b70814a32d4aa067e10280a02",
    "author": Object {
      "email": "sindresorhus@gmail.com",
      "name": "Sindre Sorhus",
      "url": "https://sindresorhus.com",
    },
    "bugs": Object {
      "url": "https://github.com/sindresorhus/execa/issues",
    },
    "description": "Process execution for humans",
    "dist-tags": Object {
      "latest": "5.0.0",
      "next": "2.0.0-alpha.0",
    },
    "homepage": "https://github.com/sindresorhus/execa#readme",
    "keywords": Array [
      "exec",
      "child",
      "process",
      "execute",
      "fork",
      "execfile",
      "spawn",
      "file",
      "shell",
      "bin",
      "binary",
      "binaries",
      "npm",
      "path",
      "local",
    ],
    "license": "MIT",
    "maintainers": Array [
      Object {
        "email": "sindresorhus@gmail.com",
        "name": "sindresorhus",
      },
      Object {
        "email": "ehmicky@gmail.com",
        "name": "ehmicky",
      },
    ],
    "name": "execa",
    "readme": "<img src=\\"media/logo.svg\\" width=\\"400\\">
<br>

[![Coverage Status](https://codecov.io/gh/sindresorhus/execa/branch/master/graph/badge.svg)](https://codecov.io/gh/sindresorhus/execa)

> Process execution for humans

## Why

This package improves [\`child_process\`](https://nodejs.org/api/child_process.html) methods with:

- Promise interface.
- [Strips the final newline](#stripfinalnewline) from the output so you don't have to do \`stdout.trim()\`.
- Supports [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) binaries cross-platform.
- [Improved Windows support.](https://github.com/IndigoUnited/node-cross-spawn#why)
- Higher max buffer. 100 MB instead of 200 KB.
- [Executes locally installed binaries by name.](#preferlocal)
- [Cleans up spawned processes when the parent process dies.](#cleanup)
- [Get interleaved output](#all) from \`stdout\` and \`stderr\` similar to what is printed on the terminal. [*(Async only)*](#execasyncfile-arguments-options)
- [Can specify file and arguments as a single string without a shell](#execacommandcommand-options)
- More descriptive errors.

## Install

\`\`\`
$ npm install execa
\`\`\`

## Usage

\`\`\`js
const execa = require('execa');

(async () => {
	const {stdout} = await execa('echo', ['unicorns']);
	console.log(stdout);
	//=> 'unicorns'
})();
\`\`\`

### Pipe the child process stdout to the parent

\`\`\`js
const execa = require('execa');

execa('echo', ['unicorns']).stdout.pipe(process.stdout);
\`\`\`

### Handling Errors

\`\`\`js
const execa = require('execa');

(async () => {
	// Catching an error
	try {
		await execa('unknown', ['command']);
	} catch (error) {
		console.log(error);
		/*
		{
			message: 'Command failed with ENOENT: unknown command spawn unknown ENOENT',
			errno: -2,
			code: 'ENOENT',
			syscall: 'spawn unknown',
			path: 'unknown',
			spawnargs: ['command'],
			originalMessage: 'spawn unknown ENOENT',
			shortMessage: 'Command failed with ENOENT: unknown command spawn unknown ENOENT',
			command: 'unknown command',
			stdout: '',
			stderr: '',
			all: '',
			failed: true,
			timedOut: false,
			isCanceled: false,
			killed: false
		}
		*/
	}

})();
\`\`\`

### Cancelling a spawned process

\`\`\`js
const execa = require('execa');

(async () => {
	const subprocess = execa('node');

	setTimeout(() => {
		subprocess.cancel();
	}, 1000);

	try {
		await subprocess;
	} catch (error) {
		console.log(subprocess.killed); // true
		console.log(error.isCanceled); // true
	}
})()
\`\`\`

### Catching an error with the sync method

\`\`\`js
try {
	execa.sync('unknown', ['command']);
} catch (error) {
	console.log(error);
	/*
	{
		message: 'Command failed with ENOENT: unknown command spawnSync unknown ENOENT',
		errno: -2,
		code: 'ENOENT',
		syscall: 'spawnSync unknown',
		path: 'unknown',
		spawnargs: ['command'],
		originalMessage: 'spawnSync unknown ENOENT',
		shortMessage: 'Command failed with ENOENT: unknown command spawnSync unknown ENOENT',
		command: 'unknown command',
		stdout: '',
		stderr: '',
		all: '',
		failed: true,
		timedOut: false,
		isCanceled: false,
		killed: false
	}
	*/
}
\`\`\`

### Kill a process

Using SIGTERM, and after 2 seconds, kill it with SIGKILL.

\`\`\`js
const subprocess = execa('node');

setTimeout(() => {
	subprocess.kill('SIGTERM', {
		forceKillAfterTimeout: 2000
	});
}, 1000);
\`\`\`

## API

### execa(file, arguments, options?)

Execute a file. Think of this as a mix of [\`child_process.execFile()\`](https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback) and [\`child_process.spawn()\`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options).

No escaping/quoting is needed.

Unless the [\`shell\`](#shell) option is used, no shell interpreter (Bash, \`cmd.exe\`, etc.) is used, so shell features such as variables substitution (\`echo $PATH\`) are not allowed.

Returns a [\`child_process\` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess) which:
  - is also a \`Promise\` resolving or rejecting with a [\`childProcessResult\`](#childProcessResult).
  - exposes the following additional methods and properties.

#### kill(signal?, options?)

Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal) except: if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.

##### options.forceKillAfterTimeout

Type: \`number | false\`\\\\
Default: \`5000\`

Milliseconds to wait for the child process to terminate before sending \`SIGKILL\`.

Can be disabled with \`false\`.

#### cancel()

Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.

#### all

Type: \`ReadableStream | undefined\`

Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

This is \`undefined\` if either:
  - the [\`all\` option](#all-2) is \`false\` (the default value)
  - both [\`stdout\`](#stdout-1) and [\`stderr\`](#stderr-1) options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)

### execa.sync(file, arguments?, options?)

Execute a file synchronously.

Returns or throws a [\`childProcessResult\`](#childProcessResult).

### execa.command(command, options?)

Same as [\`execa()\`](#execafile-arguments-options) except both file and arguments are specified in a single \`command\` string. For example, \`execa('echo', ['unicorns'])\` is the same as \`execa.command('echo unicorns')\`.

If the file or an argument contains spaces, they must be escaped with backslashes. This matters especially if \`command\` is not a constant but a variable, for example with \`__dirname\` or \`process.cwd()\`. Except for spaces, no escaping/quoting is needed.

The [\`shell\` option](#shell) must be used if the \`command\` uses shell-specific features, as opposed to being a simple \`file\` followed by its \`arguments\`.

### execa.commandSync(command, options?)

Same as [\`execa.command()\`](#execacommand-command-options) but synchronous.

Returns or throws a [\`childProcessResult\`](#childProcessResult).

### execa.node(scriptPath, arguments?, options?)

Execute a Node.js script as a child process.

Same as \`execa('node', [scriptPath, ...arguments], options)\` except (like [\`child_process#fork()\`](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options)):
  - the current Node version and options are used. This can be overridden using the [\`nodePath\`](#nodepath-for-node-only) and [\`nodeOptions\`](#nodeoptions-for-node-only) options.
  - the [\`shell\`](#shell) option cannot be used
  - an extra channel [\`ipc\`](https://nodejs.org/api/child_process.html#child_process_options_stdio) is passed to [\`stdio\`](#stdio)

### childProcessResult

Type: \`object\`

Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

The child process [fails](#failed) when:
- its [exit code](#exitcode) is not \`0\`
- it was [killed](#killed) with a [signal](#signal)
- [timing out](#timedout)
- [being canceled](#iscanceled)
- there's not enough memory or there are already too many child processes

#### command

Type: \`string\`

The file and arguments that were run.

#### exitCode

Type: \`number\`

The numeric exit code of the process that was run.

#### stdout

Type: \`string | Buffer\`

The output of the process on stdout.

#### stderr

Type: \`string | Buffer\`

The output of the process on stderr.

#### all

Type: \`string | Buffer | undefined\`

The output of the process with \`stdout\` and \`stderr\` interleaved.

This is \`undefined\` if either:
  - the [\`all\` option](#all-2) is \`false\` (the default value)
  - \`execa.sync()\` was used

#### failed

Type: \`boolean\`

Whether the process failed to run.

#### timedOut

Type: \`boolean\`

Whether the process timed out.

#### isCanceled

Type: \`boolean\`

Whether the process was canceled.

#### killed

Type: \`boolean\`

Whether the process was killed.

#### signal

Type: \`string | undefined\`

The name of the signal that was used to terminate the process. For example, \`SIGFPE\`.

If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`.

#### signalDescription

Type: \`string | undefined\`

A human-friendly description of the signal that was used to terminate the process. For example, \`Floating point arithmetic error\`.

If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`. It is also \`undefined\` when the signal is very uncommon which should seldomly happen.

#### message

Type: \`string\`

Error message when the child process failed to run. In addition to the [underlying error message](#originalMessage), it also contains some information related to why the child process errored.

The child process [stderr](#stderr) then [stdout](#stdout) are appended to the end, separated with newlines and not interleaved.

#### shortMessage

Type: \`string\`

This is the same as the [\`message\` property](#message) except it does not include the child process stdout/stderr.

#### originalMessage

Type: \`string | undefined\`

Original error message. This is the same as the \`message\` property except it includes neither the child process stdout/stderr nor some additional information added by Execa.

This is \`undefined\` unless the child process exited due to an \`error\` event or a timeout.

### options

Type: \`object\`

#### cleanup

Type: \`boolean\`\\\\
Default: \`true\`

Kill the spawned process when the parent process exits unless either:
	- the spawned process is [\`detached\`](https://nodejs.org/api/child_process.html#child_process_options_detached)
	- the parent process is terminated abruptly, for example, with \`SIGKILL\` as opposed to \`SIGTERM\` or a normal exit

#### preferLocal

Type: \`boolean\`\\\\
Default: \`false\`

Prefer locally installed binaries when looking for a binary to execute.\\\\
If you \`$ npm install foo\`, you can then \`execa('foo')\`.

#### localDir

Type: \`string\`\\\\
Default: \`process.cwd()\`

Preferred path to find locally installed binaries in (use with \`preferLocal\`).

#### execPath

Type: \`string\`\\\\
Default: \`process.execPath\` (Current Node.js executable)

Path to the Node.js executable to use in child processes.

This can be either an absolute path or a path relative to the [\`cwd\` option](#cwd).

Requires [\`preferLocal\`](#preferlocal) to be \`true\`.

For example, this can be used together with [\`get-node\`](https://github.com/ehmicky/get-node) to run a specific Node.js version in a child process.

#### buffer

Type: \`boolean\`\\\\
Default: \`true\`

Buffer the output from the spawned process. When set to \`false\`, you must read the output of [\`stdout\`](#stdout-1) and [\`stderr\`](#stderr-1) (or [\`all\`](#all) if the [\`all\`](#all-2) option is \`true\`). Otherwise the returned promise will not be resolved/rejected.

If the spawned process fails, [\`error.stdout\`](#stdout), [\`error.stderr\`](#stderr), and [\`error.all\`](#all) will contain the buffered data.

#### input

Type: \`string | Buffer | stream.Readable\`

Write some input to the \`stdin\` of your binary.\\\\
Streams are not allowed when using the synchronous methods.

#### stdin

Type: \`string | number | Stream | undefined\`\\\\
Default: \`pipe\`

Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

#### stdout

Type: \`string | number | Stream | undefined\`\\\\
Default: \`pipe\`

Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

#### stderr

Type: \`string | number | Stream | undefined\`\\\\
Default: \`pipe\`

Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

#### all

Type: \`boolean\`\\\\
Default: \`false\`

Add an \`.all\` property on the [promise](#all) and the [resolved value](#all-1). The property contains the output of the process with \`stdout\` and \`stderr\` interleaved.

#### reject

Type: \`boolean\`\\\\
Default: \`true\`

Setting this to \`false\` resolves the promise with the error instead of rejecting it.

#### stripFinalNewline

Type: \`boolean\`\\\\
Default: \`true\`

Strip the final [newline character](https://en.wikipedia.org/wiki/Newline) from the output.

#### extendEnv

Type: \`boolean\`\\\\
Default: \`true\`

Set to \`false\` if you don't want to extend the environment variables when providing the \`env\` property.

---

Execa also accepts the below options which are the same as the options for [\`child_process#spawn()\`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options)/[\`child_process#exec()\`](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback)

#### cwd

Type: \`string\`\\\\
Default: \`process.cwd()\`

Current working directory of the child process.

#### env

Type: \`object\`\\\\
Default: \`process.env\`

Environment key-value pairs. Extends automatically from \`process.env\`. Set [\`extendEnv\`](#extendenv) to \`false\` if you don't want this.

#### argv0

Type: \`string\`

Explicitly set the value of \`argv[0]\` sent to the child process. This will be set to \`file\` if not specified.

#### stdio

Type: \`string | string[]\`\\\\
Default: \`pipe\`

Child's [stdio](https://nodejs.org/api/child_process.html#child_process_options_stdio) configuration.

#### serialization

Type: \`string\`\\\\
Default: \`'json'\`

Specify the kind of serialization used for sending messages between processes when using the [\`stdio: 'ipc'\`](#stdio) option or [\`execa.node()\`](#execanodescriptpath-arguments-options):
	- \`json\`: Uses \`JSON.stringify()\` and \`JSON.parse()\`.
	- \`advanced\`: Uses [\`v8.serialize()\`](https://nodejs.org/api/v8.html#v8_v8_serialize_value)

Requires Node.js \`13.2.0\` or later.

[More info.](https://nodejs.org/api/child_process.html#child_process_advanced_serialization)

#### detached

Type: \`boolean\`

Prepare child to run independently of its parent process. Specific behavior [depends on the platform](https://nodejs.org/api/child_process.html#child_process_options_detached).

#### uid

Type: \`number\`

Sets the user identity of the process.

#### gid

Type: \`number\`

Sets the group identity of the process.

#### shell

Type: \`boolean | string\`\\\\
Default: \`false\`

If \`true\`, runs \`file\` inside of a shell. Uses \`/bin/sh\` on UNIX and \`cmd.exe\` on Windows. A different shell can be specified as a string. The shell should understand the \`-c\` switch on UNIX or \`/d /s /c\` on Windows.

We recommend against using this option since it is:
- not cross-platform, encouraging shell-specific syntax.
- slower, because of the additional shell interpretation.
- unsafe, potentially allowing command injection.

#### encoding

Type: \`string | null\`\\\\
Default: \`utf8\`

Specify the character encoding used to decode the \`stdout\` and \`stderr\` output. If set to \`null\`, then \`stdout\` and \`stderr\` will be a \`Buffer\` instead of a string.

#### timeout

Type: \`number\`\\\\
Default: \`0\`

If timeout is greater than \`0\`, the parent will send the signal identified by the \`killSignal\` property (the default is \`SIGTERM\`) if the child runs longer than timeout milliseconds.

#### maxBuffer

Type: \`number\`\\\\
Default: \`100_000_000\` (100 MB)

Largest amount of data in bytes allowed on \`stdout\` or \`stderr\`.

#### killSignal

Type: \`string | number\`\\\\
Default: \`SIGTERM\`

Signal value to be used when the spawned process will be killed.

#### windowsVerbatimArguments

Type: \`boolean\`\\\\
Default: \`false\`

If \`true\`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to \`true\` automatically when the \`shell\` option is \`true\`.

#### windowsHide

Type: \`boolean\`\\\\
Default: \`true\`

On Windows, do not create a new console window. Please note this also prevents \`CTRL-C\` [from working](https://github.com/nodejs/node/issues/29837) on Windows.

#### nodePath *(For \`.node()\` only)*

Type: \`string\`\\\\
Default: [\`process.execPath\`](https://nodejs.org/api/process.html#process_process_execpath)

Node.js executable used to create the child process.

#### nodeOptions *(For \`.node()\` only)*

Type: \`string[]\`\\\\
Default: [\`process.execArgv\`](https://nodejs.org/api/process.html#process_process_execargv)

List of [CLI options](https://nodejs.org/api/cli.html#cli_options) passed to the Node.js executable.

## Tips

### Retry on error

Gracefully handle failures by using automatic retries and exponential backoff with the [\`p-retry\`](https://github.com/sindresorhus/p-retry) package:

\`\`\`js
const pRetry = require('p-retry');

const run = async () => {
	const results = await execa('curl', ['-sSL', 'https://sindresorhus.com/unicorn']);
	return results;
};

(async () => {
	console.log(await pRetry(run, {retries: 5}));
})();
\`\`\`

### Save and pipe output from a child process

Let's say you want to show the output of a child process in real-time while also saving it to a variable.

\`\`\`js
const execa = require('execa');

const subprocess = execa('echo', ['foo']);
subprocess.stdout.pipe(process.stdout);

(async () => {
	const {stdout} = await subprocess;
	console.log('child output:', stdout);
})();
\`\`\`

### Redirect output to a file

\`\`\`js
const execa = require('execa');

const subprocess = execa('echo', ['foo'])
subprocess.stdout.pipe(fs.createWriteStream('stdout.txt'))
\`\`\`

### Redirect input from a file

\`\`\`js
const execa = require('execa');

const subprocess = execa('cat')
fs.createReadStream('stdin.txt').pipe(subprocess.stdin)
\`\`\`

### Execute the current package's binary

\`\`\`js
const {getBinPathSync} = require('get-bin-path');

const binPath = getBinPathSync();
const subprocess = execa(binPath);
\`\`\`

\`execa\` can be combined with [\`get-bin-path\`](https://github.com/ehmicky/get-bin-path) to test the current package's binary. As opposed to hard-coding the path to the binary, this validates that the \`package.json\` \`bin\` field is correctly set up.

## Related

- [gulp-execa](https://github.com/ehmicky/gulp-execa) - Gulp plugin for \`execa\`
- [nvexeca](https://github.com/ehmicky/nvexeca) - Run \`execa\` using any Node.js version
- [sudo-prompt](https://github.com/jorangreef/sudo-prompt) - Run commands with elevated privileges.

## Maintainers

- [Sindre Sorhus](https://github.com/sindresorhus)
- [@ehmicky](https://github.com/ehmicky)

---

<div align=\\"center\\">
	<b>
		<a href=\\"https://tidelift.com/subscription/pkg/npm-execa?utm_source=npm-execa&utm_medium=referral&utm_campaign=readme\\">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>
",
    "readmeFilename": "readme.md",
    "repository": Object {
      "type": "git",
      "url": "git+https://github.com/sindresorhus/execa.git",
    },
    "time": Object {
      "0.1.0": "2015-12-05T23:03:32.752Z",
      "0.1.1": "2015-12-07T10:22:42.263Z",
      "0.10.0": "2018-03-15T04:59:55.439Z",
      "0.11.0": "2018-08-20T07:57:57.953Z",
      "0.2.0": "2016-01-09T13:45:54.248Z",
      "0.2.1": "2016-01-09T13:59:27.544Z",
      "0.2.2": "2016-01-11T12:24:35.580Z",
      "0.3.0": "2016-04-22T21:13:14.859Z",
      "0.4.0": "2016-04-26T17:27:36.260Z",
      "0.5.0": "2016-10-05T08:28:19.328Z",
      "0.5.1": "2017-01-08T15:31:59.664Z",
      "0.6.0": "2017-01-09T09:37:57.298Z",
      "0.6.1": "2017-03-13T06:34:43.860Z",
      "0.6.2": "2017-03-20T05:57:19.501Z",
      "0.6.3": "2017-03-21T12:31:01.154Z",
      "0.7.0": "2017-06-09T21:50:42.038Z",
      "0.8.0": "2017-08-05T20:44:47.515Z",
      "0.9.0": "2018-01-11T23:29:49.655Z",
      "1.0.0": "2018-08-26T17:43:44.171Z",
      "2.0.0": "2019-06-25T11:26:42.705Z",
      "2.0.0-alpha.0": "2019-06-18T17:47:06.429Z",
      "2.0.1": "2019-06-26T10:13:29.987Z",
      "2.0.2": "2019-07-01T10:26:38.202Z",
      "2.0.3": "2019-07-05T08:35:52.894Z",
      "2.0.4": "2019-08-15T10:33:01.051Z",
      "2.0.5": "2019-10-04T08:05:55.676Z",
      "2.1.0": "2019-10-09T09:10:42.025Z",
      "3.0.0": "2019-10-14T14:08:16.289Z",
      "3.1.0": "2019-10-15T18:34:55.311Z",
      "3.2.0": "2019-10-17T15:11:51.894Z",
      "3.3.0": "2019-11-12T10:07:50.203Z",
      "3.4.0": "2019-11-25T10:19:23.519Z",
      "4.0.0": "2019-12-19T09:49:46.049Z",
      "4.0.1": "2020-05-08T14:19:42.795Z",
      "4.0.2": "2020-05-22T14:08:36.806Z",
      "4.0.3": "2020-07-07T18:32:23.136Z",
      "4.1.0": "2020-10-28T11:30:52.359Z",
      "5.0.0": "2020-12-03T05:19:51.155Z",
      "created": "2015-12-05T23:03:32.752Z",
      "modified": "2020-12-03T05:19:53.501Z",
    },
    "users": Object {
      "abhisekp": true,
      "adius": true,
      "aidenzou": true,
      "andrewjensen": true,
      "antixrist": true,
      "arttse": true,
      "bobxuyang": true,
      "brainpoint": true,
      "chaoliu": true,
      "chocolateboy": true,
      "d-band": true,
      "daizch": true,
      "eliverlara": true,
      "fengmiaosen": true,
      "garthk": true,
      "houzhanfeng": true,
      "huhgawz": true,
      "jamescostian": true,
      "king.v": true,
      "kodekracker": true,
      "l3au": true,
      "liunian": true,
      "pftom": true,
      "piecioshka": true,
      "pillar0514": true,
      "reyronald": true,
      "ricardogobbosouza": true,
      "santi8ago8": true,
      "serge-nikitin": true,
      "shadowwzw": true,
      "shervinafshar": true,
      "shuoshubao": true,
      "thing772": true,
      "timdp": true,
      "tjfwalker": true,
      "tommytroylin": true,
      "uxabdullah": true,
      "xiechao06": true,
      "xudaolong": true,
      "zuojiang": true,
    },
    "versions": Object {
      "0.1.0": Object {
        "_from": ".",
        "_id": "execa@0.1.0",
        "_nodeVersion": "4.2.1",
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.14.7",
        "_shasum": "4aa2ee98eaeb921a394aeca1e0966e50765b8053",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "2.0.1",
          "object-assign": "^4.0.1",
          "strip-eof": "^1.0.0",
        },
        "description": "A better child_process.{execFile,exec}",
        "devDependencies": Object {
          "ava": "*",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "4aa2ee98eaeb921a394aeca1e0966e50765b8053",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.1.0.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "a9d06c8d1e2e7c2b8a2a368bb07a9dbabfc16bd9",
        "homepage": "https://github.com/sindresorhus/execa",
        "keywords": Array [
          "exec",
          "execute",
          "fork",
          "child",
          "process",
          "execfile",
          "file",
          "bin",
          "binary",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "https://github.com/sindresorhus/execa",
        },
        "scripts": Object {
          "test": "xo && ava",
        },
        "version": "0.1.0",
        "xo": Object {
          "ignores": Array [
            "test.js",
          ],
        },
      },
      "0.1.1": Object {
        "_from": ".",
        "_id": "execa@0.1.1",
        "_nodeVersion": "4.2.1",
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.14.7",
        "_shasum": "b09c2a9309bc0ef0501479472db3180f8d4c3edd",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "^2.1.1",
          "object-assign": "^4.0.1",
          "strip-eof": "^1.0.0",
        },
        "description": "A better child_process.{execFile,exec}",
        "devDependencies": Object {
          "ava": "*",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "b09c2a9309bc0ef0501479472db3180f8d4c3edd",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.1.1.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "10df60c077ec53b10f083c89f5267c3d19af8248",
        "homepage": "https://github.com/sindresorhus/execa",
        "keywords": Array [
          "exec",
          "execute",
          "fork",
          "child",
          "process",
          "execfile",
          "file",
          "bin",
          "binary",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "https://github.com/sindresorhus/execa",
        },
        "scripts": Object {
          "test": "xo && ava",
        },
        "version": "0.1.1",
        "xo": Object {
          "ignores": Array [
            "test.js",
          ],
        },
      },
      "0.10.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@0.10.0",
        "_nodeVersion": "8.9.4",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_0.10.0_1521089995380_0.5877823423115993",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "5.6.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.0",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^2.0.0",
          "is-running": "^2.0.0",
          "nyc": "^11.0.2",
          "tempfile": "^2.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 6,
          "integrity": "sha512-7XOMnz8Ynx1gGo/3hyV9loYNPWM94jG3+3T3Y8tsfSstFmETmENCMU/A/zj8Lyaj1lkgEepKepvd6240tBRvlw==",
          "shasum": "ff456a8f53f90f8eccc71a96d11bdfc7f082cb50",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.10.0.tgz",
          "unpackedSize": 19657,
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "658f2201116ae3014b26a25e8a9ae63ba2ac41ca",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.10.0",
      },
      "0.11.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@0.11.0",
        "_nodeVersion": "8.11.3",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_0.11.0_1534751877736_0.15763076989916147",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "5.6.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.0",
          "get-stream": "^4.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^3.0.1",
          "delay": "^3.0.0",
          "is-running": "^2.0.0",
          "nyc": "^13.0.1",
          "tempfile": "^2.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 6,
          "integrity": "sha512-k5AR22vCt1DcfeiRixW46U5tMLtBg44ssdJM9PiXw3D8Bn5qyxFCSnKY/eR22y+ctFDGPqafpaXg2G4Emyua4A==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJbenSGCRA9TVsSAnZWagAAjWkP/0L0L1ZM7PSdEOxI/s3H
yh1oubc/ek2l3amjnFU37EzbhsDPRxEdFxmjl8m327L2SKxZbSETaf0Z/tnc
vsoZ0Cveb32RvJCZYmQTEYmYQSk/sXfoeNlIaI/lvzndINHwakq37W8INHIz
36SbmwSPQFNR9vGuHExGx6jB93+vkPHDHgFhYLDlGZfH05SpGf4M3JDBAXBw
y+gdLLDmqCgSJlhH5bBlcEvHnXusX+vleyxp5Y0/hDpL+Yd1Lln4u32fBPqP
bXFj14F+0xzXS8baBKjB/OfOF+5GsFuw3WWhmC1/EecFloYpNlMhg1qxkYhL
/Ves1LDYxwEm/NV7mfJ3lK7dV1KpTqhmpcDwo+1ME3eiEpkHDOVkaxIAVjmJ
ckcYEQPi2XBKWdQ3qO6+1k30ZUQmV8zHPFmk/0ZvZZ4QwE//rhLh5FsekOUo
sZcASLcvYvPHFhQcsCNk61oZGMIWoohB3FfapAylFZdn24SQhQIufNAxlC19
8gGN29tlcfhq5BD22RJJBXOmHbrz2zrI/kx+nNqAVaeg5p5WD197KO4is0zN
qyM5t1QIc3oHg7XsszYaLm5Er4ZCKzAq4NovEpg3lWs0r47cA3DmSFBdViae
LWTnLT02DLv3hSmJIHkJHErnnYpQZWo9/hbDfEgOz0ci2Uvl9vLK0XM5HRU8
qpGB
=D7f/
-----END PGP SIGNATURE-----
",
          "shasum": "0b3c71daf9b9159c252a863cd981af1b4410d97a",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.11.0.tgz",
          "unpackedSize": 19886,
        },
        "engines": Object {
          "node": ">=6",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "20ab0a1c10b815fb4eac1e11638803d6d09b3f1d",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.11.0",
      },
      "0.2.0": Object {
        "_from": ".",
        "_id": "execa@0.2.0",
        "_nodeVersion": "4.2.4",
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.14.12",
        "_shasum": "3178cf42a19d63726f2731e30239007c19f5bf4d",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "^2.1.1",
          "npm-run-path": "^1.0.0",
          "object-assign": "^4.0.1",
          "path-key": "^1.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "3178cf42a19d63726f2731e30239007c19f5bf4d",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.2.0.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "c210feb770aad510b6f1689b589d2a0b4bbba435",
        "homepage": "https://github.com/sindresorhus/execa",
        "keywords": Array [
          "exec",
          "execute",
          "fork",
          "child",
          "process",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "https://github.com/sindresorhus/execa",
        },
        "scripts": Object {
          "test": "xo && ava",
        },
        "version": "0.2.0",
      },
      "0.2.1": Object {
        "_from": ".",
        "_id": "execa@0.2.1",
        "_nodeVersion": "4.2.4",
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.14.12",
        "_shasum": "14d4f6eb9c9264220da410be73b9bdba69c90d19",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "^2.1.1",
          "npm-run-path": "^1.0.0",
          "object-assign": "^4.0.1",
          "path-key": "^1.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "14d4f6eb9c9264220da410be73b9bdba69c90d19",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.2.1.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "6e1d0c74408a6028115b16adfb12e3ae3322e3a4",
        "homepage": "https://github.com/sindresorhus/execa",
        "keywords": Array [
          "exec",
          "execute",
          "fork",
          "child",
          "process",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "https://github.com/sindresorhus/execa",
        },
        "scripts": Object {
          "test": "xo && ava",
        },
        "version": "0.2.1",
      },
      "0.2.2": Object {
        "_from": ".",
        "_id": "execa@0.2.2",
        "_nodeVersion": "4.2.4",
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.14.12",
        "_shasum": "e2ead472c2c31aad6f73f1ac956eef45e12320cb",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "^2.1.1",
          "npm-run-path": "^1.0.0",
          "object-assign": "^4.0.1",
          "path-key": "^1.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "e2ead472c2c31aad6f73f1ac956eef45e12320cb",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.2.2.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "f63fefa5dad103be2ae8ac74a2d1412cf68d4a7e",
        "homepage": "https://github.com/sindresorhus/execa",
        "keywords": Array [
          "exec",
          "execute",
          "fork",
          "child",
          "process",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "https://github.com/sindresorhus/execa",
        },
        "scripts": Object {
          "test": "xo && ava",
        },
        "version": "0.2.2",
      },
      "0.3.0": Object {
        "_from": ".",
        "_id": "execa@0.3.0",
        "_nodeVersion": "4.4.2",
        "_npmOperationalInternal": Object {
          "host": "packages-12-west.internal.npmjs.com",
          "tmp": "tmp/execa-0.3.0.tgz_1461359594289_0.6561324871145189",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "3.8.7",
        "_shasum": "a144cf33f2c1b69d4c0e29fa4c5afc956346e24c",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "^2.1.1",
          "npm-run-path": "^1.0.0",
          "object-assign": "^4.0.1",
          "path-key": "^1.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "get-stream": "^2.0.0",
          "nyc": "^6.4.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "a144cf33f2c1b69d4c0e29fa4c5afc956346e24c",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.3.0.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "f7863497e034c1bbbf3fbef6e7522c0643c7e309",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "coveralls": "nyc report --reporter=text-lcov | coveralls",
          "test": "xo && nyc ava",
        },
        "version": "0.3.0",
      },
      "0.4.0": Object {
        "_from": ".",
        "_id": "execa@0.4.0",
        "_nodeVersion": "4.4.2",
        "_npmOperationalInternal": Object {
          "host": "packages-12-west.internal.npmjs.com",
          "tmp": "tmp/execa-0.4.0.tgz_1461691655825_0.48842903040349483",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "3.8.8",
        "_shasum": "4eb6467a36a095fabb2970ff9d5e3fb7bce6ebc3",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn-async": "^2.1.1",
          "is-stream": "^1.1.0",
          "npm-run-path": "^1.0.0",
          "object-assign": "^4.0.1",
          "path-key": "^1.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "get-stream": "^2.0.0",
          "nyc": "^6.4.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "4eb6467a36a095fabb2970ff9d5e3fb7bce6ebc3",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.4.0.tgz",
        },
        "engines": Object {
          "node": ">=0.12",
        },
        "files": Array [
          "index.js",
        ],
        "gitHead": "c72609605b1ce2fcf42b913cd91e74503cd8d629",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "coveralls": "nyc report --reporter=text-lcov | coveralls",
          "test": "xo && nyc ava",
        },
        "version": "0.4.0",
      },
      "0.5.0": Object {
        "_from": ".",
        "_id": "execa@0.5.0",
        "_nodeVersion": "6.6.0",
        "_npmOperationalInternal": Object {
          "host": "packages-16-east.internal.npmjs.com",
          "tmp": "tmp/execa-0.5.0.tgz_1475656096594_0.8247949031647295",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "3.10.3",
        "_shasum": "a57456764b990e3e52f6eff7f17a9cc2ff2e7ccc",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^4.0.0",
          "get-stream": "^2.2.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^1.3.1",
          "is-running": "^2.0.0",
          "nyc": "^8.3.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "a57456764b990e3e52f6eff7f17a9cc2ff2e7ccc",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.5.0.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "842be7c11a33c71177ea03ff12412047f3d8bd07",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "node_modules",
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.5.0",
        "xo": Object {
          "esnext": true,
        },
      },
      "0.5.1": Object {
        "_from": ".",
        "_id": "execa@0.5.1",
        "_nodeVersion": "4.6.2",
        "_npmOperationalInternal": Object {
          "host": "packages-12-west.internal.npmjs.com",
          "tmp": "tmp/execa-0.5.1.tgz_1483889519424_0.4603614055085927",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.15.11",
        "_shasum": "de3fb85cb8d6e91c85bcbceb164581785cb57b36",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^4.0.0",
          "get-stream": "^2.2.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^1.3.1",
          "is-running": "^2.0.0",
          "nyc": "^8.3.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "de3fb85cb8d6e91c85bcbceb164581785cb57b36",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.5.1.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "e5598cf42a5433ff1f7954f9cd31a57b429d4875",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "node_modules",
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.5.1",
        "xo": Object {
          "esnext": true,
        },
      },
      "0.6.0": Object {
        "_from": ".",
        "_id": "execa@0.6.0",
        "_nodeVersion": "4.6.2",
        "_npmOperationalInternal": Object {
          "host": "packages-18-east.internal.npmjs.com",
          "tmp": "tmp/execa-0.6.0.tgz_1483954675252_0.4171230620704591",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.15.11",
        "_shasum": "934fc9f04a9febb4d4b449d976e92cfd95ef4f6e",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^1.3.1",
          "is-running": "^2.0.0",
          "nyc": "^10.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "934fc9f04a9febb4d4b449d976e92cfd95ef4f6e",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.6.0.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "af6667af5efcfc1470606ce5eb433017c3b3ae0a",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.6.0",
        "xo": Object {
          "esnext": true,
        },
      },
      "0.6.1": Object {
        "_from": ".",
        "_id": "execa@0.6.1",
        "_nodeVersion": "7.7.2",
        "_npmOperationalInternal": Object {
          "host": "packages-12-west.internal.npmjs.com",
          "tmp": "tmp/execa-0.6.1.tgz_1489386883556_0.7629855342675",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "4.1.2",
        "_shasum": "79eda42ade78c387718b0aad48e0f573b5525cde",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^1.3.1",
          "is-running": "^2.0.0",
          "nyc": "^10.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "79eda42ade78c387718b0aad48e0f573b5525cde",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.6.1.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "f2d80c68df34804a039af441fdfeffb84624d100",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.6.1",
        "xo": Object {
          "esnext": true,
        },
      },
      "0.6.2": Object {
        "_from": ".",
        "_id": "execa@0.6.2",
        "_nodeVersion": "4.7.3",
        "_npmOperationalInternal": Object {
          "host": "packages-18-east.internal.npmjs.com",
          "tmp": "tmp/execa-0.6.2.tgz_1489989437493_0.39953839825466275",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.15.11",
        "_shasum": "04e9e38dec6b8e770cf0fb6cf7ef945260c67bbb",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^1.3.1",
          "is-running": "^2.0.0",
          "nyc": "^10.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "04e9e38dec6b8e770cf0fb6cf7ef945260c67bbb",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.6.2.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "f28c01d854f1427674be2c9c2f9b220fce4dd970",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.6.2",
        "xo": Object {
          "esnext": true,
        },
      },
      "0.6.3": Object {
        "_from": ".",
        "_id": "execa@0.6.3",
        "_nodeVersion": "4.7.3",
        "_npmOperationalInternal": Object {
          "host": "packages-12-west.internal.npmjs.com",
          "tmp": "tmp/execa-0.6.3.tgz_1490099460925_0.15050783357582986",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.15.11",
        "_shasum": "57b69a594f081759c69e5370f0d17b9cb11658fe",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^1.3.1",
          "is-running": "^2.0.0",
          "nyc": "^10.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "57b69a594f081759c69e5370f0d17b9cb11658fe",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.6.3.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "2892941f582608f2e1f79b584761392906553feb",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.6.3",
        "xo": Object {
          "esnext": true,
        },
      },
      "0.7.0": Object {
        "_from": ".",
        "_id": "execa@0.7.0",
        "_nodeVersion": "4.8.3",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa-0.7.0.tgz_1497045041009_0.3423430174589157",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.15.11",
        "_shasum": "944becd34cc41ee32a63a9faf27ad5a65fc59777",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^2.0.0",
          "is-running": "^2.0.0",
          "nyc": "^11.0.2",
          "tempfile": "^2.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "944becd34cc41ee32a63a9faf27ad5a65fc59777",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.7.0.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "b4d1c8613fd068e3c36f11e7bff672d008ac88f9",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.7.0",
      },
      "0.8.0": Object {
        "_from": ".",
        "_id": "execa@0.8.0",
        "_nodeVersion": "4.8.3",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa-0.8.0.tgz_1501965886445_0.050055725732818246",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "2.15.11",
        "_shasum": "d8d76bbc1b55217ed190fd6dd49d3c774ecfc8da",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^2.0.0",
          "is-running": "^2.0.0",
          "nyc": "^11.0.2",
          "tempfile": "^2.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "shasum": "d8d76bbc1b55217ed190fd6dd49d3c774ecfc8da",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.8.0.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "dc7e21b0754985b75a5e89917c9035beac1f1f2e",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.8.0",
      },
      "0.9.0": Object {
        "_id": "execa@0.9.0",
        "_nodeVersion": "8.9.4",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa-0.9.0.tgz_1515713388594_0.54020432732068",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "5.6.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^5.0.1",
          "get-stream": "^3.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^2.11.9",
          "delay": "^2.0.0",
          "is-running": "^2.0.0",
          "nyc": "^11.0.2",
          "tempfile": "^2.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "integrity": "sha512-BbUMBiX4hqiHZUA5+JujIjNb6TyAlp2D5KLheMjMluwOuzcnylDL4AxZYLLn1n2AGB49eSWwyKvvEQoRpnAtmA==",
          "shasum": "adb7ce62cf985071f60580deb4a88b9e34712d01",
          "tarball": "https://registry.npmjs.org/execa/-/execa-0.9.0.tgz",
        },
        "engines": Object {
          "node": ">=4",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "b01989521f514f3578c48c8302e648008ed4fd0d",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "0.9.0",
      },
      "1.0.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@1.0.0",
        "_nodeVersion": "8.11.3",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_1.0.0_1535305424092_0.2806930373405232",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "6.4.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.0",
          "get-stream": "^4.0.0",
          "is-stream": "^1.1.0",
          "npm-run-path": "^2.0.0",
          "p-finally": "^1.0.0",
          "signal-exit": "^3.0.0",
          "strip-eof": "^1.0.0",
        },
        "description": "A better \`child_process\`",
        "devDependencies": Object {
          "ava": "*",
          "cat-names": "^1.0.2",
          "coveralls": "^3.0.1",
          "delay": "^3.0.0",
          "is-running": "^2.0.0",
          "nyc": "^13.0.1",
          "tempfile": "^2.0.0",
          "xo": "*",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 6,
          "integrity": "sha512-adbxcyWV46qiHyvSp50TKt05tB4tK3HcmF7/nxfAdhnox83seTDbwnaqKO4sXRy7roHAIFqJP/Rw/AuEbX61LA==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJbgubQCRA9TVsSAnZWagAAIsEQAIs35D02H15nByFfN/Ht
MtyJPq3y8M4HKouIKuHWiO1auu6fmt/uhFpzNJJfnwhJoZBUPs/OZBi2w8jr
4zglnRGX5w323oLVFEZHWIUny6YSNnDsxjKnDkrKw6j/3Z/dAo6o/QPO4/4n
VgyLhQQuhvNnB6z6iH9tgpxTwyVcVetWqJOBT3T4idkbgAmZAsE/m/1RoUUN
uq/72dV8H4jomYCvKvoeVsj+RpeTuCGoQFwoN/xjkuHh0EqWp3D13wJyc8Pc
2tS2+mf/0FZaMFEELoMV6W6dBI320xSBgD1mc0zJ8fy//oDmjctiIKVKEQRJ
CPiQIuKKZ2HlC7cHUnGK9KNHk3DLiHVi6gJxepzdoSUArrF4J23v7JyQxzpm
R12+DwMIL+TF3e/+XljqfpmNlbShh1Bvmx56ih2to9JafN0BobOHRMrQcqSz
mcnFQCpQIGx4Cck0/TaumL3mZDsZ9DS6jPKrYEeJ5MkgU0Y2/p1MIB6dbhae
vGJRmYlDuXm7DNTDdpuUo+vTYtRWvXA+O7K1V7lwavUbJ/eA+dlwxfcAKJFD
6QKrVKtnCJmQqfP9rwJSXCYtWQ90+gGfoNDijcpoQj9H3pqcCnM0bAKaJbOm
0s+k2TpbCFu9sqlGAYLZl3uwV3FqdyjrAWW/zjvn/S7O6cxjiYFk/Qhn+OS4
s9FU
=B9g6
-----END PGP SIGNATURE-----
",
          "shasum": "c6236a5bb4df6d6f15e88e7f017798216749ddd8",
          "tarball": "https://registry.npmjs.org/execa/-/execa-1.0.0.tgz",
          "unpackedSize": 19885,
        },
        "engines": Object {
          "node": ">=6",
        },
        "files": Array [
          "index.js",
          "lib",
        ],
        "gitHead": "c8dccf7de66c65f4b9b821ec00871fea386fb35f",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
          "reporter": Array [
            "text",
            "lcov",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava",
        },
        "version": "1.0.0",
      },
      "2.0.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.0",
        "_nodeVersion": "12.4.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.0_1561462002347_0.23088144698910895",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.9.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 8,
          "integrity": "sha512-+ym7S09yUVPHEhYBsdLm53ZjCmCSeAQVtM/iN9dDj9tbvcBnCeBXTXHPWR9HXzht+vslGROteM8bSUdr4YszUg==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdEgTzCRA9TVsSAnZWagAAlpwP/0bQY0rGMMR2Nc3aN+gI
flCPqr4gPHOLYm+BAbN9mRX7FdligHlfD2NxIxZRt6tzm+lutU6176GGJAic
aljEbzuh7ISrTNMtQqh9ZbZygBxrr44CLp6EkzZZHO3Wcq3T6/lTSP5E1daE
zYSA/40n/g9++k4WOean+x1A5j8oci2UHsyCi8YhBEFr9OLhZ59KU6hst/8O
3O5saM67YIquIj7fbQtumgleeCTUDon8+73iiriHloO8vvcEQF0kvAXEoC6l
S86R9wfbAg1/J4J9X10k2OApICs9TnBBdXYULHEjiV4Fc5J9NVEPp9Q3uKHn
kVfrAkz9PKOr2a5Ornt8FFw57qFNj3sl1JD0a7VGHlW3c5gx+Bg05EHpAL7A
EFmoRlsoLQpVLwhNbIEQgaR0LuKAdc3ONYJdPhxeQiK8lP7mhRFrMjWITTl2
IIkzOVAeM/VWSgzb6GuKElGiUc0sBrqZKy7VJQ5Hp7eEPu+KgXwffhnYKt+3
XE7dglGwswDttDvHqVBsZswxUh5uRrV/aDqZsRYURguSW0WmThV7NMps02h9
kElOTjrWieeBQBpcRMm9G9ehRCNNDu7v3VIxCzPZfyrlBwd1ldIjHmKPTWfe
EF/aenUFuPLh2Leq7Z4iCKD2Ldjeh9ACkNGYf5lp0gVeuA5Ou+B2d64Te9nY
3n4Y
=LuG8
-----END PGP SIGNATURE-----
",
          "shasum": "5524c9739710e603e97c6dfc3f6ff6bff2819885",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.0.tgz",
          "unpackedSize": 45890,
        },
        "engines": Object {
          "node": ">=8",
        },
        "gitHead": "ec10a4c7b5732edb76e7a20e29ffa3996bcde80a",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.0",
      },
      "2.0.0-alpha.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.0-alpha.0",
        "_nodeVersion": "8.16.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.0-alpha.0_1560880026342_0.693813967595307",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "6.9.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 6,
          "integrity": "sha512-hYFS8zsUOomvssfNT8E7U5FJ3JLQgOxSE4s1ZVpxgWzL8eZX0g+GOg/FDrIXnLMlcEIyYHtpsvskn3eHaEUBpg==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdCSObCRA9TVsSAnZWagAARiwP/3ars0mbLZWXz99tPO+N
ieaaHQa/ixJAxs2QY7pGwzL7nFG+YSeHExvwkbL7+lUhuGU+8oy57m2Y68c4
p6fX15GrMF0PpekBamHbH0ntveAwit97M3RnYm2FdZV4oTVeopur8Vik0Dis
YdsrIscRqxdsM2L7bYr0VciggJEgynjStvCxYs8CCJTyH8VsRt03A8YRC1aU
BaSZeqKxBZejQEm2yxkNtFO9PQXYSt0gwU2q1FUxe4+4s499Q7V8pLtqF6p9
NFyWfeqbbHJLa+dcZBqjNi7OvBzatna3LqycY/sJKetnZeR7CYqBoYE0q/La
F2D8utEdJFfQW9BVAcJecu1qqtQNCCdiiNQUrIdCP6yfJLsLobetu155jfQS
I9XvyTZg7Cf8pIz7jLzLp3+HNNYBoN29LSmDbuwudTzvtqPvBBkD6vGZAVp8
GGlYcfnOezyRILmlEa6LhNdPpOv9OK94XuZDo6IwnqYEV9cSpbPuUrozFNQq
0v1oPeD08QexlGEsnBnS9YW8vTNWEJpneDtUNV0WTHAZjYKqClebuEjIjA9Q
iLBfS1tK3nwq2ccs+hqjAHKKKdh030eoI1HdgEb7Y5dc0dvcr5QG2GiNMGGE
YdkHjZ+zSPeR4h68pNvbZCPc4sTu02NfClu8RiFfq8Xnei/VJ0gZINEtxiPQ
KPSD
=wTql
-----END PGP SIGNATURE-----
",
          "shasum": "e9525fa152c1d1da165448f77505db3a7aa57c0d",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.0-alpha.0.tgz",
          "unpackedSize": 43829,
        },
        "engines": Object {
          "node": ">=8",
        },
        "gitHead": "1880029f1090e9419010d6a43e85e9d20b305069",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "readme": "<img src=\\"media/logo.svg\\" width=\\"400\\">
<br>

[![Build Status](https://travis-ci.org/sindresorhus/execa.svg?branch=master)](https://travis-ci.org/sindresorhus/execa) [![Coverage Status](https://coveralls.io/repos/github/sindresorhus/execa/badge.svg?branch=master)](https://coveralls.io/github/sindresorhus/execa?branch=master)

> Process execution for humans


---

One of the maintainers [@ehmicky](https://github.com/ehmicky) is looking for a remote full-time position as a Node.js back-end lead. Feel free to [contact him](https://www.mickael-hebert.com)!

---


## Why

This package improves [\`child_process\`](https://nodejs.org/api/child_process.html) methods with:

- Promise interface.
- [Strips the final newline](#stripfinalnewline) from the output so you don't have to do \`stdout.trim()\`.
- Supports [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) binaries cross-platform.
- [Improved Windows support.](https://github.com/IndigoUnited/node-cross-spawn#why)
- Higher max buffer. 100 MB instead of 200 KB.
- [Executes locally installed binaries by name.](#preferlocal)
- [Cleans up spawned processes when the parent process dies.](#cleanup)
- [Get interleaved output](#all) from \`stdout\` and \`stderr\` similar to what is printed on the terminal. [*(Async only)*](#execasyncfile-arguments-options)
- [Can specify file and arguments as a single string without a shell](#execacommandcommand-options)
- More descriptive errors.


## Install

\`\`\`
$ npm install execa
\`\`\`


## Usage

\`\`\`js
const execa = require('execa');

(async () => {
	const {stdout} = await execa('echo', ['unicorns']);
	console.log(stdout);
	//=> 'unicorns'
})();
\`\`\`

Additional examples:

\`\`\`js
const execa = require('execa');

(async () => {
	// Pipe the child process stdout to the current stdout
	execa('echo', ['unicorns']).stdout.pipe(process.stdout);


	// Catching an error
	try {
		await execa('wrong', ['command']);
	} catch (error) {
		console.log(error);
		/*
		{
			message: 'Command failed with exit code 2 (ENOENT): wrong command spawn wrong ENOENT',
			errno: 'ENOENT',
			syscall: 'spawn wrong',
			path: 'wrong',
			spawnargs: ['command'],
			command: 'wrong command',
			exitCode: 2,
			exitCodeName: 'ENOENT',
			stdout: '',
			stderr: '',
			all: '',
			failed: true,
			timedOut: false,
			isCanceled: false,
			killed: false
		}
		*/
	}

	// Cancelling a spawned process
	const subprocess = execa('node');
	setTimeout(() => {
		subprocess.cancel();
	}, 1000);
	try {
		await subprocess;
	} catch (error) {
		console.log(subprocess.killed); // true
		console.log(error.isCanceled); // true
	}
})();

// Catching an error with a sync method
try {
	execa.sync('wrong', ['command']);
} catch (error) {
	console.log(error);
	/*
	{
		message: 'Command failed with exit code 2 (ENOENT): wrong command spawnSync wrong ENOENT',
		errno: 'ENOENT',
		syscall: 'spawnSync wrong',
		path: 'wrong',
		spawnargs: ['command'],
		command: 'wrong command',
		exitCode: 2,
		exitCodeName: 'ENOENT',
		stdout: '',
		stderr: '',
		failed: true,
		timedOut: false,
		isCanceled: false,
		killed: false
	}
	*/
}

// Kill a process with SIGTERM, and after 2 seconds, kill it with SIGKILL
const subprocess = execa('node');
setTimeout(() => {
	subprocess.kill('SIGTERM', {
		forceKillAfterTimeout: 2000
	});
}, 1000);
\`\`\`

## API

### execa(file, arguments, [options])

Execute a file. Think of this as a mix of [\`child_process.execFile()\`](https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback) and [\`child_process.spawn()\`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options).

No escaping/quoting is needed.

Unless the [\`shell\`](#shell) option is used, no shell interpreter (Bash, \`cmd.exe\`, etc.) is used, so shell features such as variables substitution (\`echo $PATH\`) are not allowed.

Returns a [\`child_process\` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess) which:
  - is also a \`Promise\` resolving or rejecting with a [\`childProcessResult\`](#childProcessResult).
  - exposes the following additional methods and properties.

#### kill([signal], [options])

Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal) except: if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.

##### options.forceKillAfterTimeout

Type: \`number | false\`<br>
Default: \`5000\`

Milliseconds to wait for the child process to terminate before sending \`SIGKILL\`.

Can be disabled with \`false\`.

#### cancel()

Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.

#### all

Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

### execa.sync(file, [arguments], [options])

Execute a file synchronously.

Returns or throws a [\`childProcessResult\`](#childProcessResult).

### execa.command(command, [options])

Same as [\`execa()\`](#execafile-arguments-options) except both file and arguments are specified in a single \`command\` string. For example, \`execa('echo', ['unicorns'])\` is the same as \`execa.command('echo unicorns')\`.

If the file or an argument contains spaces, they must be escaped with backslashes. This matters especially if \`command\` is not a constant but a variable, for example with \`__dirname\` or \`process.cwd()\`. Except for spaces, no escaping/quoting is needed.

### execa.commandSync(command, [options])

Same as [\`execa.command()\`](#execacommand-command-options) but synchronous.

Returns or throws a [\`childProcessResult\`](#childProcessResult).

### execa.node(scriptPath, [arguments], [options])

Execute a Node.js script as a child process.

Same as \`execa('node', [file, ...arguments], options)\` except (like [\`child_process#fork()\`](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options)):
  - the [\`nodePath\`](#nodepath-for-node-only) and [\`nodeArguments\`](#nodearguments-for-node-only) options can be used
  - the [\`shell\`](#shell) option cannot be used 
  - an extra channel [\`ipc\`](https://nodejs.org/api/child_process.html#child_process_options_stdio) is passed to [\`stdio\`](#stdio)

### childProcessResult

Type: \`object\`

Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

#### command

Type: \`string\`

The file and arguments that were run.

#### exitCode

Type: \`number\`

The numeric exit code of the process that was run.

#### exitCodeName

Type: \`string\`

The textual exit code of the process that was run.

#### stdout

Type: \`string | Buffer\`

The output of the process on stdout.

#### stderr

Type: \`string | Buffer\`

The output of the process on stderr.

#### all

Type: \`string | Buffer\`

The output of the process on both stdout and stderr. \`undefined\` if \`execa.sync()\` was used.

#### failed

Type: \`boolean\`

Whether the process failed to run.

#### timedOut

Type: \`boolean\`

Whether the process timed out.

#### isCanceled

Type: \`boolean\`

Whether the process was canceled.

#### killed

Type: \`boolean\`

Whether the process was killed.

#### signal

Type: \`string | undefined\`

The signal that was used to terminate the process.

### options

Type: \`object\`

#### cleanup

Type: \`boolean\`<br>
Default: \`true\`

Kill the spawned process when the parent process exits unless either:
	- the spawned process is [\`detached\`](https://nodejs.org/api/child_process.html#child_process_options_detached)
	- the parent process is terminated abruptly, for example, with \`SIGKILL\` as opposed to \`SIGTERM\` or a normal exit

#### preferLocal

Type: \`boolean\`<br>
Default: \`true\`

Prefer locally installed binaries when looking for a binary to execute.<br>
If you \`$ npm install foo\`, you can then \`execa('foo')\`.

#### localDir

Type: \`string\`<br>
Default: \`process.cwd()\`

Preferred path to find locally installed binaries in (use with \`preferLocal\`).

#### buffer

Type: \`boolean\`<br>
Default: \`true\`

Buffer the output from the spawned process. When buffering is disabled you must consume the output of the \`stdout\` and \`stderr\` streams because the promise will not be resolved/rejected until they have completed.

If the spawned process fails, [\`error.stdout\`](#stdout), [\`error.stderr\`](#stderr), and [\`error.all\`](#all) will contain the buffered data.

#### input

Type: \`string | Buffer | stream.Readable\`

Write some input to the \`stdin\` of your binary.<br>
Streams are not allowed when using the synchronous methods.

#### stdin

Type: \`string | number | Stream | undefined\`<br>
Default: \`pipe\`

Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

#### stdout

Type: \`string | number | Stream | undefined\`<br>
Default: \`pipe\`

Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

#### stderr

Type: \`string | number | Stream | undefined\`<br>
Default: \`pipe\`

Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

#### reject

Type: \`boolean\`<br>
Default: \`true\`

Setting this to \`false\` resolves the promise with the error instead of rejecting it.

#### stripFinalNewline

Type: \`boolean\`<br>
Default: \`true\`

Strip the final [newline character](https://en.wikipedia.org/wiki/Newline) from the output.

#### extendEnv

Type: \`boolean\`<br>
Default: \`true\`

Set to \`false\` if you don't want to extend the environment variables when providing the \`env\` property.

---

Execa also accepts the below options which are the same as the options for [\`child_process#spawn()\`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options)/[\`child_process#exec()\`](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback)

#### cwd

Type: \`string\`<br>
Default: \`process.cwd()\`

Current working directory of the child process.

#### env

Type: \`object\`<br>
Default: \`process.env\`

Environment key-value pairs. Extends automatically from \`process.env\`. Set [\`extendEnv\`](#extendenv) to \`false\` if you don't want this.

#### argv0

Type: \`string\`

Explicitly set the value of \`argv[0]\` sent to the child process. This will be set to \`file\` if not specified.

#### stdio

Type: \`string | string[]\`<br>
Default: \`pipe\`

Child's [stdio](https://nodejs.org/api/child_process.html#child_process_options_stdio) configuration.

#### detached

Type: \`boolean\`

Prepare child to run independently of its parent process. Specific behavior [depends on the platform](https://nodejs.org/api/child_process.html#child_process_options_detached).

#### uid

Type: \`number\`

Sets the user identity of the process.

#### gid

Type: \`number\`

Sets the group identity of the process.

#### shell

Type: \`boolean | string\`<br>
Default: \`false\`

If \`true\`, runs \`file\` inside of a shell. Uses \`/bin/sh\` on UNIX and \`cmd.exe\` on Windows. A different shell can be specified as a string. The shell should understand the \`-c\` switch on UNIX or \`/d /s /c\` on Windows.

We recommend against using this option since it is:
- not cross-platform, encouraging shell-specific syntax.
- slower, because of the additional shell interpretation.
- unsafe, potentially allowing command injection.

#### encoding

Type: \`string | null\`<br>
Default: \`utf8\`

Specify the character encoding used to decode the \`stdout\` and \`stderr\` output. If set to \`null\`, then \`stdout\` and \`stderr\` will be a \`Buffer\` instead of a string.

#### timeout

Type: \`number\`<br>
Default: \`0\`

If timeout is greater than \`0\`, the parent will send the signal identified by the \`killSignal\` property (the default is \`SIGTERM\`) if the child runs longer than timeout milliseconds.

#### maxBuffer

Type: \`number\`<br>
Default: \`100_000_000\` (100 MB)

Largest amount of data in bytes allowed on \`stdout\` or \`stderr\`.

#### killSignal

Type: \`string | number\`<br>
Default: \`SIGTERM\`

Signal value to be used when the spawned process will be killed.

#### windowsVerbatimArguments

Type: \`boolean\`<br>
Default: \`false\`

If \`true\`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to \`true\` automatically when the \`shell\` option is \`true\`.

#### nodePath *(for \`.node()\` only)*

Type: \`string\`<br>
Default: [\`process.execPath\`](https://nodejs.org/api/process.html#process_process_execpath)

Node.js executable used to create the child process.

#### nodeArguments *(for \`.node()\` only)*

Type: \`string[]\`<br>
Default: [\`process.execArgv\`](https://nodejs.org/api/process.html#process_process_execargv)

List of string arguments passed to the Node.js executable.

## Tips

### Save and pipe output from a child process

Let's say you want to show the output of a child process in real-time while also saving it to a variable.

\`\`\`js
const execa = require('execa');

const subprocess = execa('echo', ['foo']);
subprocess.stdout.pipe(process.stdout);

(async () => {
	const {stdout} = await subprocess;
	console.log('child output:', stdout);
})();
\`\`\`

### Redirect output to a file

\`\`\`js
const execa = require('execa');

const subprocess = execa('echo', ['foo'])
subprocess.stdout.pipe(fs.createWriteStream('stdout.txt'))
\`\`\`

### Redirect input from a file

\`\`\`js
const execa = require('execa');

const subprocess = execa('cat')
fs.createReadStream('stdin.txt').pipe(subprocess.stdin)
\`\`\`


## Related

- [gulp-execa](https://github.com/ehmicky/gulp-execa) - Gulp plugin for \`execa\`


## Maintainers

- [Sindre Sorhus](https://github.com/sindresorhus)
- [@ehmicky](https://github.com/ehmicky)


---

<div align=\\"center\\">
	<b>
		<a href=\\"https://tidelift.com/subscription/pkg/npm-execa?utm_source=npm-execa&utm_medium=referral&utm_campaign=readme\\">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>
",
        "readmeFilename": "readme.md",
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.0-alpha.0",
      },
      "2.0.1": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.1",
        "_nodeVersion": "12.4.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.1_1561544009863_0.7631312059436064",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.9.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 9,
          "integrity": "sha512-pHGXlV7S7ilDda3eaCTcr6zmFTMA3wJo7j+RtNg0uH9sbAasJfVug5RkYOTBLj5g4MOqlsaPUn3HKa/UfTDw8w==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdE0VKCRA9TVsSAnZWagAABdMP/i1JInnH6kQ0ol50grPQ
mPbQTWMgKMmVinDV7QXK/sh8LDXh4BYpjIUvmeNvdCJsZ7a4yjxCts6UZmgq
pl0I0ykbZo189vg6J7JCU4gB+lRra1WoD/hItQ1Oceo1rvgqckGnsbWEAJyn
5OClVzAkyT4divp1E+2agKPuYk33iSfPMeQqoWboqTbEIbIISV2mjlZansAH
bPmG+zjk5sppny4uD3omoNpS/fb1WWbUhHD1xQ0xS5bWFOikO3xdIYXouci+
VEPX4puXWliy6FkJ+7Jr5Vlzuqeh4vyxwP26yzvvybZmZbj3dUtywE3jpXqp
I3dS+MnSBKRU0FZit/y5F4bUEizBvNVIM/0HqbDCgIt93j/pmbPZRL9/kJnH
LvAHHI/njPfim+0X0Se4KRAy1h0baJ4WPqWN90KThv14fotw2prAQA2szhyI
RzPHoHo8IXyhzKR0Q3nuoGFqXpK/41t+Wczjnvbiih+LgA9Orua+qdtKlnfT
/DqXDe7PDwslk8IIceb0hCMShIkxTU3B2YsRzglyHgqtKbiwSU5qsI0tKpN7
ahOSerjkXJv8ff+KHGa3VKBo230AzQN1ErBdRwhXWAilhg+uiLG2pY1dXQE+
f0XQFgZSjrMa4SSMVvhn24d2YJha/BnYI+Bhh2GBuraV1AYPzzj+XisgH7ft
vjTJ
=D4qD
-----END PGP SIGNATURE-----
",
          "shasum": "546a5be56388953409cbf24972d2fd1bb36dbfcd",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.1.tgz",
          "unpackedSize": 46571,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "97ef87d5d30542041d69cb4942bc10f98fc7579c",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.1",
      },
      "2.0.2": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.2",
        "_nodeVersion": "12.5.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.2_1561976798094_0.39987737236232634",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.9.2",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 12,
          "integrity": "sha512-CkFnhVuWj5stQUvRSeI+zAw0ME+Iprkew4HKSc491vOXLM+hKrDVn+QQoL2CIYy0CpvT0mY+MXlzPreNbuj/8A==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdGd/eCRA9TVsSAnZWagAAXAUQAKP7eiP/GC9qFWPmWNBb
bTCDkt+g/8m+NL84TMqpxe9iEK/qZmGw6WZ/YPrH6Q77VAmpTQfbJ449O52Y
G2TbhdtRsP8CHIhwtpL7CdljgrmxoUWqLvMPthVSDmY48U/lgL7pmLKXSlgx
pq1zws7f8hOX78EGYmCms1VlHYWv2WNUuYplJiHdC6x7nPxPmBdvayE++seE
W9NQ1fkJJwvfcrhZSEMbE9V0Q5avW4eAeXkp0trdUKPWfuNZr0w0qqGfn618
n+zSIjkF+n6Cb8uQrmy33m9KkN6VrCuR9HJ8pxjLbZexSsderHHMeVifPpAi
lAlcKVlSPgEpZ18kOS43B8HsdmfiSLU0j+BZpnud0rj8lQatwZzbz8Hv43PF
pdppKqAKBQhKDFXgYq3wy/6Hbl3Oy3Zq86pPwMmz6Co/mz8YvObR+AvZOKZP
ma0YxBBbINRgzGwVmcNZy5ZFiGbwt5Py7HBsBDFzhmj/Tkr2eN8TzF8hV6kP
a7gJH5OsFtLgssWHCZprNybOupKnOxYV3Tx0udIO0IsnK1BVTRnk0pWRUkuq
NCMpVTWLjVSwJjfv0G8jR3WwPPIWTtPGixtV1X+a9GmpuYmaSGpLTo2vHtyT
fHK2Jf+wt/YFghYvoBo4BqbvQLuO83azrS3NUizJ9VyfnkpZKKomU5E+cU3Y
FJTM
=E3BZ
-----END PGP SIGNATURE-----
",
          "shasum": "3af2650be2b719549dc011a53118ecff5e28d0a2",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.2.tgz",
          "unpackedSize": 48201,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "8977752a1036a50223b6a572ae5d1a103853c158",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.2",
      },
      "2.0.3": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.3",
        "_nodeVersion": "12.6.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.3_1562315752728_0.1958378699659593",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.10.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 12,
          "integrity": "sha512-iM124nlyGSrXmuyZF1EMe83ESY2chIYVyDRZKgmcDynid2Q2v/+GuE7gNMl6Sy9Niwf4MC0DDxagOxeMPjuLsw==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdHwvpCRA9TVsSAnZWagAAmiEQAJa8bkwYfcJcMAS1JFbT
7nXhQjoKnQpx9+z4NY10dVpyEAcR1DujgE+60w8yt9Vf+ionFO6QA08iyMXE
TaeOAzcgT0lgN58sw8apxG2DniM3F0iRhe4lf5LUnATn7oBAAv6G7cNAKtvz
v9ttFBPWXllJk6R6NR6uPsIikKzfppWxepkFZsYIsGbK1/tHVBv4oe9tH3JD
Ql4HqRQtK5Sd+5I9DxulpVm/CLgOvhUhhDWscz6znrhRx7f6cYrTzZNGsBqD
IfVqLqxWg/cbCmloI5ufaqd7keujhMwEc9R64BOvu03HLofoIahPpaZTh90b
3Kx9I5JuMcEsMeGQBtIOxUs4jRc+mpKojYWS1k4CHTOlaKgVWSi7WQ42iF/5
/9h6sB+mNjnuNZNnzlmouYiJwzykJaqONRzjOu0dy+SpphtFywiSfuLJBfiw
6IWLuLGZ2kbGlan3roC9UbpLQ2es+kTSVX/OdbcrgncGV6TThalW8wNe3mua
jI3IDYy3B6yu1x0Juo5wtZLlSYxb3jyxw5YY0dL5hOAgrzXD1YfBZ+/oyqs2
oo+ft4fTQMgtqFLqK6F0BgE1CkgmWgbJRKab/FT2YeggHGrtc5lAPFxhGzWA
6QlWJp39HMUQhEOu0Zs/AuUU4ndQXJ2UltKyHFEpgQDAnHX5T3in8W66PTwF
VzjU
=xW4d
-----END PGP SIGNATURE-----
",
          "shasum": "4b84301b33042cfb622771e886ed0b10e5634642",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.3.tgz",
          "unpackedSize": 49420,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "0cdc62cbdc9ad7879316363dce9b17ce1e6239c9",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.3",
      },
      "2.0.4": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.4",
        "_nodeVersion": "10.16.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.4_1565865180934_0.5626446401512586",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "6.9.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-VcQfhuGD51vQUQtKIq2fjGDLDbL6N1DTQVpYzxZ7LPIXw3HqTuIz6uxRmpV1qf8i31LHf2kjiaGI+GdHwRgbnQ==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdVTTdCRA9TVsSAnZWagAA/6MP/1r1dCYF5tJKR4KOWS98
VhLZa9tSQpqfzNbSMXNkxeezDBC33T0CFbaRN3blg/ZSMqMJyxvht7tDT8pO
IBvC84WYenDWdh0f7HshyKtYVwjhcbHWVJTsgouJHcDUfmn97G4bgQM9WRzX
y2I90r5M72/ismLareNH9Cm/ew3Z2C4oiZZz8yF4FJ31QOwGADZn1D5CrxMn
kO7P02rWz5uzuN6LIovy77aqUfBDf9Lc0Skv/PhXVexfFeUIPzVye7XJeatv
zBaddVyW0+2MfY7U9SOJqKtZYVECFjwqFBrdDYo3gbMRPAUcYZOuZ64opPRS
+wAJw6U2uRVC3V4auSh5Z2YWTWZ10apn3ctB342UOoXzk7dYqFBo0JPdq5g1
7ooAOSDoYnm8C/Jr0PCwWXDVWOtTfL7+lGMroG/ivoSZTbtGuXWwZ4AuvI+D
7o0dHW+czNFuQub6t8uP3cjNuX2DeWzsms3d8iwT0cJa6KEEN43qclCXkvT1
01SCJmyrvLgIff5OKG1gslJS92t/jobiTLktJAzQCpMk/7Xp7rBrcQyCNFit
NUSaTmaBt9WlCJ4AW8M4CxtaVam9x5gxsUfUUm38aWq3G9cDPMn/caPkSrEc
DQoE9aT18qKIGhb7gjPD+ylgRdtHgc20Kl3/UsZq766zqr2oj2K1ygRh52N2
FJPt
=xww6
-----END PGP SIGNATURE-----
",
          "shasum": "2f5cc589c81db316628627004ea4e37b93391d8e",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.4.tgz",
          "unpackedSize": 48211,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "ac2bc15e1598317e4698eba5ba171927e4159655",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.4",
      },
      "2.0.5": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.0.5",
        "_nodeVersion": "12.11.1",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.0.5_1570176355504_0.6711622418588583",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.11.3",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^6.0.5",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-SwmwZZyJjflcqLSgllk4EQlMLst2p9muyzwNugKGFlpAz6rZ7M+s2nBR97GAq4Vzjwx2y9rcMcmqzojwN+xwNA==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdlv1kCRA9TVsSAnZWagAA6WoP/Ruhb5Zm2Xt9DAUQC8mM
2aOMw5rY1InHESuvwnASMOGlzqf6BQOQfQ2FqL/Yj7UVQvRbDrt5c7gZxLts
fuqVVxHJfizwqkD8QR4NByj9Btvrhr7Gqxzhe/6bjsK4/c0xttv3bge2La+2
VGOCbi7/5RNluvieHVW0+ivkaSVzIw6QLr8VazcLwOSx/DosnoXVuluHEBtY
z/hxamrFsmSdxqyZKwjVMmHyme3xoI5U7l6eL6g0gpsTD4qo4ewupbeIVkcI
gvzf7UOg8N6XIFWDa4frzf8efN44kVZvtJV+zgDcrWBr7sAbAFRJmMp/LrUK
3d5jCGEjKEB1+MxACmA8iUnk8TYhKujWFaMhf2v7ii7I9ZFTamnQtMxsFryn
hmcwfgM+xh8ZbmccSyXMzWJlDevBJy0sZUm8y+OGTLjf1hX/Rvz5ke4aNOSV
qmawCmGcFwGnRYhUxwBiQy1fO80fa/tmu3y/jHWWty0sRNtuPERAiGywXEmC
sgJGo2f2lEXCi7JlDFQTIyb/9Iihxhf8XmP2dc91cPJKk5fy8uh//tH/4XVA
HQes4NOo0O9tFGkm8tUo++t3vpiieInl6BNFaCiX6UDLV8lVBGvvCgXpouG6
isOyXsFYw7fDaTlUZ6LtxxHLze4/KfwQzMRIBiqG4x5sbNVuGFo5RtdZQHrd
GtT0
=TZDC
-----END PGP SIGNATURE-----
",
          "shasum": "5be3e2ea7e61bd038da5a0e11dc6ab2097357f2f",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.0.5.tgz",
          "unpackedSize": 48198,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "603537aa05e933d0585645fbe4f94da3e20746d6",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.0.5",
      },
      "2.1.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@2.1.0",
        "_nodeVersion": "12.11.1",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_2.1.0_1570612241889_0.2434126485284398",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.12.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^3.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-Y/URAVapfbYy2Xp/gb6A0E7iR8xeqOCXsuuaoMn7A5PzrXUK84E1gyiEfq0wQd/GHA6GsoHWwhNq8anb0mleIw==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdnaQSCRA9TVsSAnZWagAASL0P/02jQZx5VhDm7oPvuJyG
OFhgQC0whEsBhWIcAUTEBvzsXEka649Xi86B6SdnbHmIQjMoCGJ9ArpBSVG2
46PaLLtmUCO+gZLYmS/Lb3AA1VEa8XbdYdtCdPuOAAu27lAtxcmd2H9dK2Ro
tPSFcq/6hrWGkzips9riXKpHD4YBbUCkgVz8NHx7CQMHv9YWxI9rfQllAhIe
gxdsbTJ7sV39ZaWvz8B3wcNRgHsZt97xgAbcg4kij1pu+1ywLJl/VX86RIj9
T0S3b+/uZZBjJDQhWrmrGNZdvKjtAScv15QYTKXDoHuMMu45HLB3GRHgLn86
gsDEXDLa/1jWZXgoOQrppugdBI44IUTswwdcDfdC9i11v3BTbjzoeL/HQ7aN
j+/CwRxJ9okDidN9OsJiMlOpO9X/YL7xLq6BfVUekcXmmrWOUZgFu1UIZ9LS
nCSF7gpysKci2ZTSDWO/rdkWG19EUqKsL6iwuoT/s6AeLNSyi46aq7icyeDK
84/X3gTU6c2tI9WCkXtJEC538Aa0qR1H89rQaTuA2mTP8Ho9fmWvWn2HPVJc
p23BYEobG1T1XO7LHRjecJQ7jZ4l1H/8aLRNmmFe+IBKdMFEADOcD3+pk32y
hj64Q/OK8T0MuVnXZWazUwDuko48Xl5VCikNEBqthJ7GF4E9sPhW8ZnHpx4a
P3jJ
=nKfP
-----END PGP SIGNATURE-----
",
          "shasum": "e5d3ecd837d2a60ec50f3da78fd39767747bbe99",
          "tarball": "https://registry.npmjs.org/execa/-/execa-2.1.0.tgz",
          "unpackedSize": 49164,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "e98561a71df16695f56700d7be406ec8fe41f0a3",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "2.1.0",
      },
      "3.0.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@3.0.0",
        "_nodeVersion": "12.12.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_3.0.0_1571062096154_0.8706696268911771",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.12.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-U3sotWWSGb19r7wVY3OcUgS/S/7VXbh3DQkYfPHaEKveYhgb+GqNN0YTkpnaeI7Ho2oIQ0Na6Mt98M93/wtqGw==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdpIFRCRA9TVsSAnZWagAA8FcP/jd5RZ5TmbSC++FXpAw1
LhkB29EG/swloWgkuJppTdYzEapz0TEYRescuThVojHY92sU4PEcyrA1TuYw
NhxgHZu3fR/lb/5TFLLHWQKTAuHfTo3PZnHg+p97gPFK9l8xYMTthLHz/+3v
gertpuCbY2jlZHLnesEvft2leUV9PYBzrdN27ZcUWnxBffLM4yYrGMp8La0j
7seYeDzm6VYsOeAgM9EK7L4tr8A2hfwWidDy6bAUON2N7DPMl1i1Ltt0LlE1
M+fxhULjgYJDrYzAnvE3Ak2YCAYyc/u20Oi5kzmjo1XiZLe5W0iJBp/o8wLQ
fu1NTtKKSDQvtc4IMrWXKaMxuDaor0Bfa7b7+0Duyo0rFbz36LoB12po6M0p
l+oPepubdnaeQFRG4C8ViACGIN1LXAwoBuK/Feu5KZmQ1KnE6u0TW43fG3xt
Sj2MhcQXSaEWsViCYQ1HFQ430AoyaR3DjD3z/0vj8oBmRAuerAGtcOHQn9Xm
ufcUoie+QeaI2MwdjmpkL/JZPgAh6QbDzHkILtRGEqYxeqm51NCw/CHrl3M7
+X29TC+RTxsob8ERFKUqPrIEmov3bz1DJycKomP7Vy6pN1erPpWwJX2APcmt
jYP28U7MFL99+Piy9fPG1naX2VgfqzOSsTKU1ZWBUIV4koUlosshvQghlT31
ncSf
=BWpf
-----END PGP SIGNATURE-----
",
          "shasum": "f38e3c24932c2ee0f472383b0dcbd40aa42f61f5",
          "tarball": "https://registry.npmjs.org/execa/-/execa-3.0.0.tgz",
          "unpackedSize": 49637,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "88dbeeeb5fca2c92b59ffebcb30f09db924f39df",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "3.0.0",
      },
      "3.1.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@3.1.0",
        "_nodeVersion": "12.12.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_3.1.0_1571164495156_0.8650414182624948",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.12.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "get-node": "^5.0.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-KcBxdjv1JlRiHMIRSDtvaGlUb6SQ4TLqxG9blJNTo6bzYYZZBHBZPKqMmK5Eftok7wl1iwDIRofxdu8tBlidQA==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdphFQCRA9TVsSAnZWagAA9wIP/1W8RLdSU53HISnp9sqa
XF6lUqHokkHESRBomDTaN9bAa9ys1yx5Ukq4AOuwu5G/3wvmKe4EjFumIAHz
55fC/n/v35RcxhDHnWK4aOTMVmaJw7NUuSl7UaO2+2RyAY1Fma1TSMLTKpqH
w5xO7kpGQp3/VUctCNKYnzehJn/9mY1G1uLsygaRBuEVYXkJYmX8BvIvAZdy
JjsgL3fn3ArdG9dUpyKiyI7ydJax5qcBhKyV3JNraNHLIW4PG9wkrxpO2d+Y
OJJ8BWVUCmX/BF4QapgzI/yG9uxOzYwHh/PioMIwIkY7DKGrnVnRrVNVzIbb
zIXJXkQud/lNC5dhZa9etUI52Ohhauths3vMF6t6G3Rpp/yfgQ7fOrtiK+ql
r9lMGzok+wUji3q6DHhtt3hbdRWHpwwYoCtzLOXR/yQP4KfxP4IRMeFzF6gm
0aJJs9KZB6aKhrfxINakaOsSCh44Ci2xxC0irOQzbRSdaaH+iyTMJsFu/SM7
RMuAYYVG1+2vT8UuOCTim5KB05ck6SXPfeWGgpRDz/QGPOq/8pVKbRjzKzgc
lPhqDNnPcMoXpMlW8zGzTCkL58MVQyNxs61DH9Ub5zBhjHgjShQYx3TmjB9s
wWwNLaLEddF7jiN5vozHQMaRCTnvkCz8Z3leUH1IexS2VUIJ0KyLp2/MKlsI
D+DA
=3056
-----END PGP SIGNATURE-----
",
          "shasum": "d7a4a54b1ef3784c3d528c2bb7107f5720356929",
          "tarball": "https://registry.npmjs.org/execa/-/execa-3.1.0.tgz",
          "unpackedSize": 50553,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "cf32d160bc5838193b7814313098bf74615acc3e",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "3.1.0",
      },
      "3.2.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@3.2.0",
        "_nodeVersion": "12.12.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_3.2.0_1571325111773_0.23596713465151553",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.12.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "get-node": "^5.0.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-kJJfVbI/lZE1PZYDI5VPxp8zXPO9rtxOkhpZ0jMKha56AI9y2gGVC6bkukStQf0ka5Rh15BA5m7cCCH4jmHqkw==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdqIS4CRA9TVsSAnZWagAAbN8QAKKrF1lkitIWmzp/qLOZ
ctI5Y6obSZkUuGSgO8BntnD7vhtwxdi8FI0dkJnhFqDst2qp+JXQDL9T03qC
oIWMxEqoxH4TSth1nCFRPT7zGa7z/csuWbhS82M5q9zs4Z2MYSa+jZ5TXUgI
+9ssIlvmmLyk2GGiJnGoxmxURO+5ASstXQ75WAaDl+dJr0lFsfs9WfVCV4yS
WW9w2JEXalcPk4geB0Sm3eTxU08hAd9GXEhXES9QhRqJRLp7kWFmazRB3yUn
GgtBmYMsgNWRC7Nqdwk9kgiha98MtYMpmKaVbwJgiB4B9xHWN4qs+p96ZaHn
8bI2+q+/uS2AXwq7LMiDSHisWj7DxJKonqGFdaH0S04ST3cMaNwvNsHqmWTx
2rvWNvP5Ds/HVIlg30E16LXfKL+CrO5XWRbsSF2SP0Jj4FQrttMCiVoiXH7X
FSENxApwome+9YTTsymyKhWrGPYzObeRymD4L5oFHl3ar/xRcjrOdOu4/ttO
ryCLGhzcCFDWpsy4JIb9GBg2tE2gEbWYXlDEZAC2tQmnehSx3AU96h1bTyQo
MF8qejuphMKIuhfS7nsfCRP/MSgm7jGYniOZRnDRXe0pe44XfLaXVZE00YNK
+UzRRKcEev3HNAL3s67mE9GTtfuLHNXF60VmC+fJt0Hx9yPZBP1B/GoBAFte
3jBN
=NMHO
-----END PGP SIGNATURE-----
",
          "shasum": "18326b79c7ab7fbd6610fd900c1b9e95fa48f90a",
          "tarball": "https://registry.npmjs.org/execa/-/execa-3.2.0.tgz",
          "unpackedSize": 51946,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "e003f9cde906d6095e176042147c31ececc02881",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "3.2.0",
      },
      "3.3.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@3.3.0",
        "_nodeVersion": "13.1.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_3.3.0_1573553270019_0.6605028401759876",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.13.0",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "get-node": "^5.0.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-j5Vit5WZR/cbHlqU97+qcnw9WHRCIL4V1SVe75VcHcD1JRBdt8fv0zw89b7CQHQdUHTt2VjuhcF5ibAgVOxqpg==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJdyoR2CRA9TVsSAnZWagAA8aQP/2xhVZOuxFLZpNM2PqFy
DyxLqVh7MLfg55vN2a02iVQvalaC2O/XG9jRgsZYHLBnB9F7fIWV0xu3uh7w
XJjK/X/LA6khMCGfuIBWXVE02EoMZgVrnh/NiqHCOz0CZWznvP0PhwYE6ntP
9/KAaiLLa0b0MqwNztXHS5FPQFtmqC4yO+i3HLPKRT609PNMOthpPkBGcl0F
4sJQTB9/fP90QX//vZ0H49Ql8+MHqmeMK8csb+G2m64LvzK/klXR3QsCXIMB
+Q57lWke4OPRym0Zz8BT32psSSKWZ+l5fsfhELKLhzI+sgHaX/RmjmgQkp2x
+gLNUF0W1QO7DiZB+dacLKarHGYzKQ4eA/xHStgM0qqIdAlXjylqIG0bgjuf
v15zM2dDfUfAJNlbi/sJgf33oj6wlgJcUE4qtOC10W3sPiQgsYYQyO66rhW+
M4aAPyvPxVA1PiV+a9U4SqsXU0sxmJi44Lflw5QWbFFFCxuViVLSsMlhfUpc
mJdFaLxXfVpjnShLwEpn7syKToUvhovVRKPjA9bQXbFP3T7afXQbQbx4mBfi
BePoVzG/9ue2xK1HVpOgLAk0TzFsFJ179mT1ULsxDpD/ltMCLeUK/EhWc2fx
hAwdmp6LqhqV6uFrjHYd/zqMH+76oU3Wg+/xLeuRTogtBJVo5y6cpKraTnAQ
vtUJ
=Vcl9
-----END PGP SIGNATURE-----
",
          "shasum": "7e348eef129a1937f21ecbbd53390942653522c1",
          "tarball": "https://registry.npmjs.org/execa/-/execa-3.3.0.tgz",
          "unpackedSize": 52934,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "f1eda9c86b93d38978c939083983424149005bdf",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "3.3.0",
      },
      "3.4.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@3.4.0",
        "_nodeVersion": "13.2.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_3.4.0_1574677163393_0.009077939891026343",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.13.1",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "p-finally": "^2.0.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.0.7",
          "ava": "^2.1.0",
          "coveralls": "^3.0.4",
          "get-node": "^5.0.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.7.3",
          "xo": "^0.24.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-r9vdGQk4bmCuK1yKQu1KTwcT2zwfWdbdaXfCtAh+5nU/4fSX+JAb7vZGvI5naJrQlvONrEB20jeruESI69530g==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJd26qrCRA9TVsSAnZWagAA9rUP/iesTqJ/YZ8RATHdbV8J
eugZ8+uVvcdEdC0Ch0R9YK/dNDhQjgCnd2gVXl/6eQ6yqrmDs6gHZq0yh0Az
/ULbMpSVX846NMIDLzbiNB0hkTg0k0owmDwg/6VNpNehOqDOFoixYITT9Y5q
B6lMhXKpbO0snAgw1lwUrPH+tZShGxdvuzlY5//XVBTVHUrWOiaC95avJ3xq
QiVQ6OenGTwGbb+AUC8w/itFfILUZ1QiWLc5+ychKoBjvAlj0fngGwHUa5Lt
TIwxOzkPn+5ifLKuMjTtwXODAODkIMVsCBi0A61BUdPulzTHQcHGqOyptkBV
yld7kgGX8cYlOJSnW2HdlMHsdhyUYDgQayUTAL+QJys74rr1iq5OIcymXB2O
OMvHh6+lzs1PCJzRJHbDT0eDuAPp5PflQ1df2fhxgNEBmCkc0ro5HFQ/aEa+
MR6xV47ICFs/9MTbyLUBTarwEpOCILfQHFnKcEf7LMNIEqFUekDZko33DTI+
X7WU5/+J4eLkebl0jefdOIxJEn2hluw/MWb6No5/TZcGZakxmHyQMa1OLaGg
ZzGEeyPeYzQfHa+fXeM2BOn3k5ww0irsF3gL64jwoq3C2mKZgYwBu9LzvPQB
MmTbPb+nWm2mlzXunK/wtbghIr0Uj3vc9JcJmSm1hj0SxkGC88NzogaWHRLf
lhud
=1Rj9
-----END PGP SIGNATURE-----
",
          "shasum": "c08ed4550ef65d858fac269ffc8572446f37eb89",
          "tarball": "https://registry.npmjs.org/execa/-/execa-3.4.0.tgz",
          "unpackedSize": 53960,
        },
        "engines": Object {
          "node": "^8.12.0 || >=9.7.0",
        },
        "gitHead": "d50146bd4260a09e1dc4a54f02b05714678fc4a2",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "3.4.0",
      },
      "4.0.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@4.0.0",
        "_nodeVersion": "13.3.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_4.0.0_1576748985916_0.9683761819540304",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.13.4",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.12.18",
          "ava": "^2.1.0",
          "coveralls": "^3.0.9",
          "get-node": "^6.6.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.11.0",
          "xo": "^0.25.3",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-JbDUxwV3BoT5ZVXQrSVbAiaXhXUkIwvbhPIwZ0N13kX+5yCzOhUNdocxB/UQRuYOHRYYwAxKYwJYc0T4D12pDA==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJd+0e6CRA9TVsSAnZWagAAIz4P/0UOdh7Dhh5LNU/9xpxy
IAmsSqqLKHVrMgCXbIQECc5UoZbEM0kOnqK2+sHJC/tTlCOC/cs6POq/85Rf
ZJXySK5Rro5w+EZIklaMQQjfNcc2GbsdRpDbTC1XWj0sNKk3fSHdX4UL4W2+
rQXlL5MpnOaaXKsQ94e16a0VTq4CfhGC9TH9dUv4jlO12sciA+1sqjInewQ7
Zve6BsGlo3jnY0/dzst4oCOya3qKQdY0dAwhzJ/C+vQa8Aa5ibNCNBExQCCq
u1V2cDU6OeR/Wmrd/84dBo3JuYxzbo/2gNTnXCpvKEM75J997DxK2iaEe59m
v0mmkQnE8gc64gn+77rVhm+rikvNBcqG0EeEGhDLFuW0Wmd9S+ImILT6biu7
XzOfu0rJ45/YmWP9R/WMjt3LvJO5XtgRO/iwK40O/0ITAQkoQIlQhLKtB6F+
DjNIHP5lfwJG9krAkbPrteFcS6X/FpORDQdV+2JMb/WutstRLwvaTmZ7JBpp
Oq9bcXwLxbbcImQunnzlBInN48bY9R1ZlnD8orrdkaxB2Dd9WaAUXKUMHtmS
dnV8Z36ahQzbW/R5O0D1qkHcmdEx85ul7Wf6n6aET/ZuqE2Rh7iiMX22xz61
kf+7QLTki7xa6piV0iFNddRJ+9RB28CY+jt9IUPHYNBagNyUL0gvUymC8uPc
7p6r
=5H5j
-----END PGP SIGNATURE-----
",
          "shasum": "7f37d6ec17f09e6b8fc53288611695b6d12b9daf",
          "tarball": "https://registry.npmjs.org/execa/-/execa-4.0.0.tgz",
          "unpackedSize": 55369,
        },
        "engines": Object {
          "node": ">=10",
        },
        "funding": "https://github.com/sindresorhus/execa?sponsor=1",
        "gitHead": "3a276a8334299947388e6a4968d4c3dcf398c197",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "4.0.0",
      },
      "4.0.1": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@4.0.1",
        "_nodeVersion": "14.0.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_4.0.1_1588947582702_0.4788909774300627",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.14.4",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.12.18",
          "ava": "^2.1.0",
          "coveralls": "^3.0.9",
          "get-node": "^6.6.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.11.0",
          "xo": "^0.25.3",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-SCjM/zlBdOK8Q5TIjOn6iEHZaPHFsMoTxXQ2nvUvtPnuohz3H2dIozSg+etNR98dGoYUp2ENSKLL/XaMmbxVgw==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJetWp/CRA9TVsSAnZWagAAm3AP/RXcr+oiTzm3HM5KvDhF
J3UeoIga0KLZQmyXPk2o6+/qLDkGin56fVfSIVjS9GZwr4ciksxyJ2ODsyOo
sEkO6pP2DgyzAILiQ6bFL/c11mL9i7IMkP8U+0hQAZUuCWTNK3pcBVAKUVLe
vViKyhbGZ0cr9NYCxPpxSlgJuFt0JvVZXadaDlyHSvZihQ7aTcoDF69x3Kde
k5+spvLavSMYX1BHlJ9uRaJXbc2xl4fOw26ec+UVZF/kP0n6YKcQTUwudnHl
N5x96N/R/JdIwkFCklILJ5YlfDN8kW+G9Ro7RBcXVK8qdaPazTzusFBySi6L
g7D50NPVZXh+swqAMB4jAKwiC/Fc2cOTQQK2jJD1xTOoUVwaEpaFHW7+ZM1m
lmCtNkQ9+5pVdDx7hWSXPvSXjHi/N7Ml2TnceS0R2yZ/aPdwI40su2pEoeom
VT9lWOrPzdYgOU/RE2tCtXWtnHstfh1jvJtiSg9ZVmDxmF2yqldwBkwiCKbi
qYbE1zavR53Bp2CCwKaNV/BNxEN3WbICn9lMPUkmn73NWehZZvcN3q9ndzoi
qa3Xv5wXZEJh8Gy4BGOqm+s/IF+Hzd/XUchD4kFhSikzwkFggeFQkLUqsiMd
bZLN2r6U9473aa5Lwf4KDY6I3Oi09LMvkCvni1TyerVMvBKH/S+fxMxqX4oi
8f5w
=sY1I
-----END PGP SIGNATURE-----
",
          "shasum": "988488781f1f0238cd156f7aaede11c3e853b4c1",
          "tarball": "https://registry.npmjs.org/execa/-/execa-4.0.1.tgz",
          "unpackedSize": 55476,
        },
        "engines": Object {
          "node": ">=10",
        },
        "funding": "https://github.com/sindresorhus/execa?sponsor=1",
        "gitHead": "e22252608647c72ced33190f1edee29375c30e57",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "4.0.1",
      },
      "4.0.2": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@4.0.2",
        "_nodeVersion": "14.2.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_4.0.2_1590156516666_0.23777898193810376",
        },
        "_npmUser": Object {
          "email": "ehmicky@gmail.com",
          "name": "ehmicky",
        },
        "_npmVersion": "6.14.5",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.12.18",
          "ava": "^2.1.0",
          "coveralls": "^3.0.9",
          "get-node": "^6.6.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.11.0",
          "xo": "^0.25.3",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-QI2zLa6CjGWdiQsmSkZoGtDx2N+cQIGb3yNolGTdjSQzydzLgYYf8LRuagp7S7fPimjcrzUDSUFd/MgzELMi4Q==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJex9zlCRA9TVsSAnZWagAAV7gP/2k0BefUStZ1hRfyHXnY
7UhjUGPqDWy+jSPDr2F+6pQmPRzmDOJd/6lMgMQQY1Ah3T3sXkrCZSwyYBkb
iH3D9ezvQlQndha1/wRMW5MYiVvwL8pvtpT9ZjDVsfhJt3xwkCxQ3ehZWnSZ
EY9LQ7AN8BwokEQQtUc3q7vzFkIVKQGY8fB3D1UGvRG4EkzOiWYeHWti6Jnz
h+sAni2+/tmCLpGGSIyPlFfBJdihFII5qzYfMBJe/ahsyJojDgL34M1GtTIw
p6wAyjLGRzGsjwZOJUG994+enb07fouxH0kPFBIU/+0DLo3NDPMDb+9Ei6XT
xIgei8AlwLuPRZNhyLkR6Y8UuSuVaPXNVXUVZUI1bj34lbCJZaQlEGsE6pni
CAIPTNfPVMloQFXcL8y2lWz36ioAwvHqLEyKRNP1YnFqiPNZGgPfIJDXaHPi
IucoDnRkEvlziIpxnWcAcc7s0GYrhEYuSj+04PMNwlBIwgQh40ClpzlpZ/Br
V53O7llwi8u1hgCTxzsnTFbYlLrbMR0z9gsjosfkfD+AEYKcG8S8JXaHdvBc
1JVP9ZNK2yUBO0ZaO12HOziJpJ5Rmk7Ps9D706KIVqSGhbK5+DByD/DKusBJ
NA3F8KH8E0wRlaYzulmhPAorC4GRr5ubsMKc5nvZjYJVkwVjFpOoUBA0NLuk
xDYh
=iTTF
-----END PGP SIGNATURE-----
",
          "shasum": "ad87fb7b2d9d564f70d2b62d511bee41d5cbb240",
          "tarball": "https://registry.npmjs.org/execa/-/execa-4.0.2.tgz",
          "unpackedSize": 55554,
        },
        "engines": Object {
          "node": ">=10",
        },
        "funding": "https://github.com/sindresorhus/execa?sponsor=1",
        "gitHead": "a827d82203a1440e585276bef5d399a5953801f1",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "4.0.2",
      },
      "4.0.3": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@4.0.3",
        "_nodeVersion": "14.5.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_4.0.3_1594146742981_0.3031261940122554",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "6.14.5",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "https://sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.12.18",
          "ava": "^2.1.0",
          "coveralls": "^3.0.9",
          "get-node": "^6.6.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.11.0",
          "xo": "^0.25.3",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-WFDXGHckXPWZX19t1kCsXzOpqX9LWYNqn4C+HqZlk/V0imTkzJZqf87ZBhvpHaftERYknpk0fjSylnXVlVgI0A==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.4
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJfBL+3CRA9TVsSAnZWagAAgCwP/R5Y6XRBOF143ZOJMkLE
qLwjdm/hKqLlPNNLQ/ITuxk38b7m8BnugBNaetymk5lwWNDv4JJvQjSlptym
WZT19WIherYlK7ZrZ/0qTvWkcrYpNLDioKXhJbYX/Lv/R6aGX7cl6ngWZWXF
9mHJy8JDUKVhfHd8+1u3eTYr4gjKHAzacGU5IVMyy+yYA41vCVy/OhAcK7wH
+LElkgTwyhGooTt3uMNlzefZ+K6M6icJVDtYPaNc+pP9yimChFMbPI6jtYSV
KKDep6YWLtNS7Is9/cytMLMWVOl8473kaQBYQNXAcw6eSiFX3zfyxaxRhPpR
FkhYWqnRpPhAEPi4yahlgQZuRLq8qNMe6t50MeERJTniKhF+M/WHenhNHpL4
j5ukuv3jSDfMYCsOwcZaIRz5d3uqYLnCtciWSXZidEsWjqNwhH3uCAXuGKFZ
4xA3t0vhT3cEmkS1i6n1B+lEZ+w5XAEFE7zfCfUKtHHAtDUUtGRxatMVfTvt
TRoTbw2Pku+Po+GUqwF/vF86ClxHlgJE0OphYJpHJEIAmYA2WRKOsabXCRne
7g24ZJxAAiOVEVHpUzXsHEWGjzdlhLo4iNJsctvlMuL0bJZfMv5bMpyU/8cy
fQbi/EoYqKfKidTQPJysePOSZ+IeTU3PpmjP1XOC0R5/ozkS80aIff53NPJo
/FPa
=IppU
-----END PGP SIGNATURE-----
",
          "shasum": "0a34dabbad6d66100bd6f2c576c8669403f317f2",
          "tarball": "https://registry.npmjs.org/execa/-/execa-4.0.3.tgz",
          "unpackedSize": 55590,
        },
        "engines": Object {
          "node": ">=10",
        },
        "funding": "https://github.com/sindresorhus/execa?sponsor=1",
        "gitHead": "26d6b0d59588794173882f78609844ea71944463",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "4.0.3",
      },
      "4.1.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@4.1.0",
        "_nodeVersion": "14.11.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_4.1.0_1603884652223_0.43876507436388446",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "6.14.8",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "https://sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.0",
          "get-stream": "^5.0.0",
          "human-signals": "^1.1.1",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.0",
          "onetime": "^5.1.0",
          "signal-exit": "^3.0.2",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^12.12.18",
          "ava": "^2.1.0",
          "coveralls": "^3.0.9",
          "get-node": "^6.6.0",
          "is-running": "^2.1.0",
          "nyc": "^14.1.1",
          "p-event": "^4.1.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.11.0",
          "xo": "^0.25.3",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-j5W0//W7f8UxAn8hXVnwG8tLwdiUy4FJLcSupCg6maBYZDpyBvTApK7KyuI4bKj8KOh1r2YH+6ucuYtJv1bTZA==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.13
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJfmVZsCRA9TVsSAnZWagAAK/UQAJp35uVM0BD9V9c3xsHY
goq9gw2XDAJWsil24n8m08Ox8QxnVjnTjwcPFTXRHbcQ5cbn5quUsH0HyAvN
xFWMn53Oh6ADkOx1DHBfwGjA7m7r23KjNiY4rhMgd/6H5S+/QE/vuF48BYsp
19zHyI2uKkFWoVPw5DyWmJ2WP6OXcITaaYmoCiR/UiXx4y7/3G2oXICQWRhd
K5jIcCGg7E8XMEvP0PNTAQSo2nY23sdor+e/AJCVkugEmjUyUztPmU0tH4ug
8lvhC3baJjwYvRbJDvMXn0/OGiTYd7ELZ7nR7bSf/9Aa+5A7rUtE1BPlDIkA
e9CzOQkAGo2DXd9JGM68kcNQnBUbpdlhvhqgFHSem0hNEoV29ZunH7XouA2B
n3L5O6eC+5hj3Zvllj9J4sLifwCqr6vzbNlsZQexVbjPb3xU/tRQQaA+Igpg
2BctAuCLoILSMzCos82LPTXVJsOgS/86YRAVMNsvBDbbF7YOdFDr0wHp6dph
hErYI/GRcLOdbnjxdN2sg/R8ZOoNrHSB0Yr02wrX0v85lyc4hsejCUnfDIcH
RrQtceM/fvLgSONPyDvEh0kVbn5xIE9QvwLXvpce4xls2DFt0CBKKka5Kpba
+BKMUEMG9ov5LWg8XLgtBDAI6u3Fb1L0YPfZ/h6s85H2ezE9oJCKP/8Hgz7e
Spdr
=T/dZ
-----END PGP SIGNATURE-----
",
          "shasum": "4e5491ad1572f2f17a77d388c6c857135b22847a",
          "tarball": "https://registry.npmjs.org/execa/-/execa-4.1.0.tgz",
          "unpackedSize": 56040,
        },
        "engines": Object {
          "node": ">=10",
        },
        "funding": "https://github.com/sindresorhus/execa?sponsor=1",
        "gitHead": "cae090f4eff220db9447de88aa05a8cfb3f89bb0",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "4.1.0",
      },
      "5.0.0": Object {
        "_hasShrinkwrap": false,
        "_id": "execa@5.0.0",
        "_nodeVersion": "10.22.1",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/execa_5.0.0_1606972790999_0.29844986618977276",
        },
        "_npmUser": Object {
          "email": "sindresorhus@gmail.com",
          "name": "sindresorhus",
        },
        "_npmVersion": "6.14.9",
        "author": Object {
          "email": "sindresorhus@gmail.com",
          "name": "Sindre Sorhus",
          "url": "https://sindresorhus.com",
        },
        "bugs": Object {
          "url": "https://github.com/sindresorhus/execa/issues",
        },
        "dependencies": Object {
          "cross-spawn": "^7.0.3",
          "get-stream": "^6.0.0",
          "human-signals": "^2.1.0",
          "is-stream": "^2.0.0",
          "merge-stream": "^2.0.0",
          "npm-run-path": "^4.0.1",
          "onetime": "^5.1.2",
          "signal-exit": "^3.0.3",
          "strip-final-newline": "^2.0.0",
        },
        "description": "Process execution for humans",
        "devDependencies": Object {
          "@types/node": "^14.14.10",
          "ava": "^2.4.0",
          "get-node": "^11.0.1",
          "is-running": "^2.1.0",
          "nyc": "^15.1.0",
          "p-event": "^4.2.0",
          "tempfile": "^3.0.0",
          "tsd": "^0.13.1",
          "xo": "^0.35.0",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 11,
          "integrity": "sha512-ov6w/2LCiuyO4RLYGdpFGjkcs0wMTgGE8PrkTHikeUy5iJekXyPIKUjifk5CsE0pt7sMCrMZ3YNqoCj6idQOnQ==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.13
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJfyHV3CRA9TVsSAnZWagAA02QP/jwfskNDXh0ws36liVSJ
o7MF8kUEaFlbGazuTGZVkqr8D/5nMSf4SyMFS8i7RkcoXh6ektT+LKiJ21xD
8lhUW0VHZfvGeIhTgAwFMQzKEJzaYxCsI4Rfmvducnv/JDGga9mG+ggsiTqV
W6ysu06A2OI6kKkBk9WdT768qpCIEnFdRskGChNsssrz77nhdoJNZXpgaUUJ
ui8gzKPCY2T4t+2J+4bLjdy5S/eyg7xRfVbm3oaE04PGxpSIcvhqA07gxNYx
1xmyVDuG5Rzc4OaNe4sy221IrYugO32fMpKPgYKcW85WwHsAOkAIZw8dvO4Z
T7XfSpygAqPIaudRoZSY/vgkwGv7XK04YZqOPaKnvij4QU4DrmGhKk6hh/k8
jvAlME/ARw3xwbsSMyP7PkcJIbMrV2BB8IyTmwMHWiqWpMcjJWG0OQ4XLqvT
ni2lNU+Y8cmw7uLgzOphb6fo43ARCaAw+VN/oY8Rkfhp96AfeFE0EgTHlPth
cTHyhCbJwj+o6y8cWRcC+MzP67fFNqiadEUqd+UMwaqPc1gorTRiBLntJwnW
gV1l9iXW2QczP5irjXdmHgoPVTRi96o/+sDkETxTFnNOr5Mq+jnQxsyoEopk
Se86wmUgddZ0yMVX4IAlD2Iu5Ie98MEfdr3znM8pt8ifxwTDCp4QUDq18u/0
192v
=uG3d
-----END PGP SIGNATURE-----
",
          "shasum": "4029b0007998a841fbd1032e5f4de86a3c1e3376",
          "tarball": "https://registry.npmjs.org/execa/-/execa-5.0.0.tgz",
          "unpackedSize": 55471,
        },
        "engines": Object {
          "node": ">=10",
        },
        "funding": "https://github.com/sindresorhus/execa?sponsor=1",
        "gitHead": "f0c1785df19ca2bf82c339f2d02bc8645070fcf2",
        "homepage": "https://github.com/sindresorhus/execa#readme",
        "keywords": Array [
          "exec",
          "child",
          "process",
          "execute",
          "fork",
          "execfile",
          "spawn",
          "file",
          "shell",
          "bin",
          "binary",
          "binaries",
          "npm",
          "path",
          "local",
        ],
        "license": "MIT",
        "maintainers": Array [
          Object {
            "email": "sindresorhus@gmail.com",
            "name": "sindresorhus",
          },
          Object {
            "email": "ehmicky@gmail.com",
            "name": "ehmicky",
          },
        ],
        "name": "execa",
        "nyc": Object {
          "exclude": Array [
            "**/fixtures/**",
            "**/test.js",
            "**/test/**",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/sindresorhus/execa.git",
        },
        "scripts": Object {
          "test": "xo && nyc ava && tsd",
        },
        "version": "5.0.0",
      },
    },
  },
}
`;

exports[`can get EPD from "sponsorsme" package 1`] = `
Object {
  "docs": Object {
    "modules": Array [
      Object {
        "isMain": false,
        "kind": "module",
        "location": Object {
          "filePath": "dist/index.d.ts",
        },
        "mainExport": Object {
          "kind": "object",
          "props": Array [
            Object {
              "kind": "prop",
              "name": "token",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
            Object {
              "kind": "prop",
              "name": "options",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
            Object {
              "kind": "prop",
              "name": "cached",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
            Object {
              "kind": "prop",
              "name": "cursor",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
            Object {
              "kind": "prop",
              "name": "hasNextPage",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
            Object {
              "kind": "prop",
              "name": "getInfo",
              "type": Object {
                "hasProps": false,
                "isOverloaded": false,
                "kind": "callable",
                "props": Array [],
                "raw": Object {
                  "nodeFullText": "/**
     * Returns information about the sponsor if it exists.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.getInfo(\\"maticzav\\")
     * \`\`\`
     */
    getInfo(login: string): Promise<Optional<Sponsorship>>;",
                  "nodeText": "getInfo(login: string): Promise<Optional<Sponsorship>>;",
                  "typeText": "(login: string) => Promise<Sponsorship>",
                },
                "sigs": Array [
                  Object {
                    "kind": "sig",
                    "params": Array [
                      Object {
                        "kind": "sigParam",
                        "name": "login",
                        "type": Object {
                          "kind": "primitive",
                          "type": "string",
                        },
                      },
                    ],
                    "return": Object {
                      "args": Array [
                        Object {
                          "kind": "typeIndexRef",
                          "link": "(dist/index).Sponsorship",
                        },
                      ],
                      "kind": "generic_instance",
                      "raw": Object {
                        "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                        "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                        "typeText": "Promise<Sponsorship>",
                      },
                      "target": Object {
                        "kind": "standard_library",
                        "location": Object {
                          "modulePath": "typescript/lib/lib.es5.d.ts",
                        },
                        "name": "Promise",
                        "raw": Object {
                          "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                          "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                          "typeText": "Promise<T>",
                        },
                      },
                    },
                  },
                ],
              },
            },
            Object {
              "kind": "prop",
              "name": "isSponsor",
              "type": Object {
                "hasProps": false,
                "isOverloaded": false,
                "kind": "callable",
                "props": Array [],
                "raw": Object {
                  "nodeFullText": "/**
     * Tells whether there exists a sponsor with the given login.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.isSponsor(\\"maticzav\\")
     * \`\`\`
     */
    isSponsor(login: string): Promise<boolean>;",
                  "nodeText": "isSponsor(login: string): Promise<boolean>;",
                  "typeText": "(login: string) => Promise<boolean>",
                },
                "sigs": Array [
                  Object {
                    "kind": "sig",
                    "params": Array [
                      Object {
                        "kind": "sigParam",
                        "name": "login",
                        "type": Object {
                          "kind": "primitive",
                          "type": "string",
                        },
                      },
                    ],
                    "return": Object {
                      "args": Array [
                        Object {
                          "kind": "primitive",
                          "type": "boolean",
                        },
                      ],
                      "kind": "generic_instance",
                      "raw": Object {
                        "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                        "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                        "typeText": "Promise<boolean>",
                      },
                      "target": Object {
                        "kind": "standard_library",
                        "location": Object {
                          "modulePath": "typescript/lib/lib.es5.d.ts",
                        },
                        "name": "Promise",
                        "raw": Object {
                          "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                          "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                          "typeText": "Promise<T>",
                        },
                      },
                    },
                  },
                ],
              },
            },
            Object {
              "kind": "prop",
              "name": "flush",
              "type": Object {
                "hasProps": false,
                "isOverloaded": false,
                "kind": "callable",
                "props": Array [],
                "raw": Object {
                  "nodeFullText": "/**
     * Clears the cache.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * sponsors.flush()
     * \`\`\`
     */
    flush(): void;",
                  "nodeText": "flush(): void;",
                  "typeText": "() => void",
                },
                "sigs": Array [
                  Object {
                    "kind": "sig",
                    "params": Array [],
                    "return": Object {
                      "kind": "primitive",
                      "type": "void",
                    },
                  },
                ],
              },
            },
            Object {
              "kind": "prop",
              "name": "find",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
            Object {
              "kind": "prop",
              "name": "sponsorshipFromEdge",
              "type": Object {
                "kind": "primitive",
                "type": "any",
              },
            },
          ],
          "raw": Object {
            "nodeFullText": "/**
 * # sponsorme
 *
 * A lightweight client that lets you check your GitHub sponsors.
 *
 * ## Installation
 *
 * \`\`\`bash
 * yarn add sponsorme
 * \`\`\`
 *
 * ## Example
 *
 * \`\`\`ts
 * let sponsors = Sponsors({ token: \\"token\\" })
 *
 * await sponsors.getInfo(\\"maticzav\\")
 * \`\`\`
 *
 * That's it!
 */
/**
 * Creates a Sponsors client that you can use to get sponsors information.
 */
export default class Sponsors {
    private token;
    private options;
    private cached;
    private cursor;
    private hasNextPage;
    constructor(opts: SponsorsOptions);
    /**
     * Returns information about the sponsor if it exists.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.getInfo(\\"maticzav\\")
     * \`\`\`
     */
    getInfo(login: string): Promise<Optional<Sponsorship>>;
    /**
     * Tells whether there exists a sponsor with the given login.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.isSponsor(\\"maticzav\\")
     * \`\`\`
     */
    isSponsor(login: string): Promise<boolean>;
    /**
     * Clears the cache.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * sponsors.flush()
     * \`\`\`
     */
    flush(): void;
    /**
     * Internal helper that finds a sponsoring for a given login.
     */
    private find;
    /**
     * Converts response's edge to Sponsorship abstract type.
     */
    private sponsorshipFromEdge;
    private static query;
}",
            "nodeText": "export default class Sponsors {
    private token;
    private options;
    private cached;
    private cursor;
    private hasNextPage;
    constructor(opts: SponsorsOptions);
    /**
     * Returns information about the sponsor if it exists.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.getInfo(\\"maticzav\\")
     * \`\`\`
     */
    getInfo(login: string): Promise<Optional<Sponsorship>>;
    /**
     * Tells whether there exists a sponsor with the given login.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.isSponsor(\\"maticzav\\")
     * \`\`\`
     */
    isSponsor(login: string): Promise<boolean>;
    /**
     * Clears the cache.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * sponsors.flush()
     * \`\`\`
     */
    flush(): void;
    /**
     * Internal helper that finds a sponsoring for a given login.
     */
    private find;
    /**
     * Converts response's edge to Sponsorship abstract type.
     */
    private sponsorshipFromEdge;
    private static query;
}",
            "typeText": "Sponsors",
          },
        },
        "name": "index",
        "namedExports": Array [
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "SponsorsOptions",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(dist/index).SponsorsOptions",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "Sponsorship",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(dist/index).Sponsorship",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "SponsorshipSponsor",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(dist/index).SponsorshipSponsor",
            },
          },
          Object {
            "isTerm": false,
            "isType": true,
            "kind": "export",
            "name": "SponsorshipTier",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(dist/index).SponsorshipTier",
            },
          },
        ],
        "path": "/dist",
        "tsdoc": null,
      },
    ],
    "typeIndex": Object {
      "(dist/index).SponsorsOptions": Object {
        "kind": "alias",
        "name": "SponsorsOptions",
        "raw": Object {
          "nodeFullText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
          "nodeText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
          "typeText": "SponsorsOptions",
        },
        "tsdoc": null,
        "type": Object {
          "kind": "object",
          "props": Array [
            Object {
              "kind": "prop",
              "name": "cache",
              "type": Object {
                "kind": "primitive",
                "type": "boolean",
              },
            },
            Object {
              "kind": "prop",
              "name": "token",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
          ],
          "raw": Object {
            "nodeFullText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
            "nodeText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
            "typeText": "SponsorsOptions",
          },
        },
        "typeParameters": Array [],
      },
      "(dist/index).Sponsorship": Object {
        "kind": "alias",
        "name": "Sponsorship",
        "raw": Object {
          "nodeFullText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
          "nodeText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
          "typeText": "Sponsorship",
        },
        "tsdoc": null,
        "type": Object {
          "kind": "object",
          "props": Array [
            Object {
              "kind": "prop",
              "name": "id",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "createdAt",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "sponsor",
              "type": Object {
                "kind": "typeIndexRef",
                "link": "(dist/index).SponsorshipSponsor",
              },
            },
            Object {
              "kind": "prop",
              "name": "public",
              "type": Object {
                "kind": "primitive",
                "type": "boolean",
              },
            },
            Object {
              "kind": "prop",
              "name": "tier",
              "type": Object {
                "kind": "typeIndexRef",
                "link": "(dist/index).SponsorshipTier",
              },
            },
          ],
          "raw": Object {
            "nodeFullText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
            "nodeText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
            "typeText": "Sponsorship",
          },
        },
        "typeParameters": Array [],
      },
      "(dist/index).SponsorshipSponsor": Object {
        "kind": "alias",
        "name": "SponsorshipSponsor",
        "raw": Object {
          "nodeFullText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
          "nodeText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
          "typeText": "SponsorshipSponsor",
        },
        "tsdoc": null,
        "type": Object {
          "kind": "object",
          "props": Array [
            Object {
              "kind": "prop",
              "name": "login",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "email",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
          ],
          "raw": Object {
            "nodeFullText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
            "nodeText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
            "typeText": "SponsorshipSponsor",
          },
        },
        "typeParameters": Array [],
      },
      "(dist/index).SponsorshipTier": Object {
        "kind": "alias",
        "name": "SponsorshipTier",
        "raw": Object {
          "nodeFullText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
          "nodeText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
          "typeText": "SponsorshipTier",
        },
        "tsdoc": null,
        "type": Object {
          "kind": "object",
          "props": Array [
            Object {
              "kind": "prop",
              "name": "id",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "createdAt",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "name",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "description",
              "type": Object {
                "kind": "primitive",
                "type": "string",
              },
            },
            Object {
              "kind": "prop",
              "name": "monthlyPriceInCents",
              "type": Object {
                "kind": "primitive",
                "type": "number",
              },
            },
          ],
          "raw": Object {
            "nodeFullText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
            "nodeText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
            "typeText": "SponsorshipTier",
          },
        },
        "typeParameters": Array [],
      },
    },
  },
  "metadata": Object {
    "_id": "sponsorsme",
    "_rev": "1-20708224bb14a8015d730f44b9722ca4",
    "author": Object {
      "email": "matic.zavadlal@gmail.com",
      "name": "Matic Zavadlal",
    },
    "bugs": Object {
      "url": "https://github.com/maticzav/sponsorsme/issues",
    },
    "description": "Lightweight package that lets you see who is sponsoring you.",
    "dist-tags": Object {
      "latest": "1.0.1",
    },
    "homepage": "https://github.com/maticzav/sponsorsme#readme",
    "license": "MIT",
    "maintainers": Array [
      Object {
        "email": "matic.zavadlal@gmail.com",
        "name": "maticzav",
      },
    ],
    "name": "sponsorsme",
    "readme": "<div align=\\"center\\"><img src=\\"media/logo.svg\\" width=\\"240\\" /></div>

# sponsorsme

![Test](https://github.com/maticzav/sponsorsme/workflows/Test/badge.svg)
[![codecov](https://codecov.io/gh/maticzav/sponsorsme/branch/main/graph/badge.svg?token=NA8CH6JE76)](https://codecov.io/gh/maticzav/sponsorsme)
[![npm version](https://badge.fury.io/js/sponsorsme.svg)](https://badge.fury.io/js/sponsorsme)

> A lightweight utility to check whether a user sponsors you.

This package lets you get paid for the work you do by leveraging the GitHub Sponsors community. It's meant to be used primarily with GitHub applications and other similar workflows, but is general enough to be used just about anywhere.

All you need to start using it is a token of your sponsored account.

## Example

\`\`\`ts
const sponsors = Sponsors({
  token: 'bearer <token>',
})

// Tells whether someone is in tiers above 10€
function isVIPSponsor(sponsorhip?: Sponsorship): boolean {
  return sponsorhip?.tier.monthlyPriceInCents >= 10 * 100
}

const sponsor = await sponsors.getInfo('maticzav')

if (isVIPSponsor(sponsor)) {
  // Do something special!!!
}
\`\`\`

## Installation

\`\`\`bash
yarn add sponsorsme
\`\`\`

You can get the token from [GitHub](https://github.com/settings/tokens). Make sure you check at least 'user' and 'read:org' in permissions list.

> ❗️ NOTE: The token you use to check whether someone is your sponsor is not the same as your GitHub application's key!

## Docs

\`\`\`ts
type SponsorsOptions = {
  /**
   * Whether the client should use internal cache or not.
   */
  cache?: boolean
  /**
   * Viewer's GitHub token used for authentication.
   * You should prefix the token with \\"bearer\\".
   */
  token: string
}

/**
 * Creates a Sponsors client that you can use to get sponsors information.
 */
class Sponsors {
  constructor(opts: SponsorsOptions): Sponsors
  /**
   * Returns information about the sponsor if it exists.
   */
  getInfo(login: string): Promise<Optional<Sponsorship>>

  /**
   * Tells whether there exists a sponsor with the given login.
   */
  isSponsor(login: string): Promise<boolean>

  /**
   * Clears the cache.
   */
  flush(): void
}

//
// Types
//

type Sponsorship = {
  id: string
  createdAt: string
  /**
   * Sponsor information.
   */
  sponsor: SponsorshipSponsor
  /**
   * Whether sponsorship is publicly visible.
   */
  public: boolean
  /**
   * Information about the tier.
   */
  tier: SponsorshipTier
}

type SponsorshipSponsor = {
  /**
   * Login handle of the sponsor.
   */
  login: string
  /**
   * Sponsor's email if available.
   */
  email?: string
}

type SponsorshipTier = {
  id: string
  createdAt: string
  /**
   * Information about the tier.
   */
  name: string
  description: string
  /**
   * The amount sponsoree receives each month.
   */
  monthlyPriceInCents: number
}
\`\`\`

## License

MIT @ Matic Zavadlal
",
    "readmeFilename": "README.md",
    "repository": Object {
      "type": "git",
      "url": "git+https://github.com/maticzav/sponsorsme.git",
    },
    "time": Object {
      "1.0.0": "2020-11-23T13:21:28.082Z",
      "1.0.1": "2020-11-27T22:36:11.668Z",
      "created": "2020-11-23T13:21:27.929Z",
      "modified": "2020-11-27T22:36:14.051Z",
    },
    "versions": Object {
      "1.0.0": Object {
        "_hasShrinkwrap": false,
        "_id": "sponsorsme@1.0.0",
        "_nodeVersion": "13.14.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/sponsorsme_1.0.0_1606137687930_0.6935039452169574",
        },
        "_npmUser": Object {
          "email": "matic.zavadlal@gmail.com",
          "name": "maticzav",
        },
        "_npmVersion": "6.14.4",
        "author": Object {
          "email": "matic.zavadlal@gmail.com",
          "name": "Matic Zavadlal",
        },
        "bugs": Object {
          "url": "https://github.com/maticzav/sponsorsme/issues",
        },
        "dependencies": Object {
          "@octokit/graphql": "^4.5.7",
        },
        "description": "Lightweight package that lets you see who is sponsoring you.",
        "devDependencies": Object {
          "@types/jest": "^26.0.15",
          "@types/node": "^14.14.6",
          "codecov": "^3.8.1",
          "husky": "^4.3.0",
          "jest": "^26.6.3",
          "prettier": "^2.1.2",
          "pretty-quick": "^3.1.0",
          "ts-jest": "^26.4.3",
          "ts-node": "^9.0.0",
          "typescript": "^4.0.5",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 9,
          "integrity": "sha512-V27Zpy9r3L0helP+3+BM6PcS3HWCZe6cfCH9wWYD2z2l3eGQbdWfDC3kDlGxQ2CLQ0bBab+PGjbCEl8MLVzP/Q==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.13
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJfu7dYCRA9TVsSAnZWagAAUP4QAJKehQj+YXsNDcCwnmDa
B75C9J/vZgZxhQ2gXTe8nHMUSXYBxwxD4KHSTGKR2gLYUztto++FUHLWNR/k
fx4LvMmwlxsoosj05GTmJIJIpTUPfqLHSKfhVXMf6eDMmPnzYbJjGP5dD6gF
Rl7MDRgtWkzlVowz1BxyIDXu8Ap/GQ3ViNAF/6/x9Y52HHPYT0mcd3N/fl/D
o4sFc/qWeB46TgTItW0b0l4rA8h1ZkCwDM1+Yu9J+61CR0ymODY02ux9Givz
lOTe3fG7bX1P2tefLljbwbCa3+wMvNzrzbFzmg0/fXT7SDGTfPrk4Mo9r26u
/kW1QNW0K7FacaL+kX8lDnhqWhJSzvOK/BtyqoDGO2ef/XsXD1LC4lMFz8NR
TXe4kujSI+fYk5TH1+iNaVt0UDnwddNcgwAxmkL4KYLs1jprjrbAm1iA+S98
LZ4pDhk2LAx1D8yzEA9wAuWvTa2wxLQzwqzoVxSyWSX/mC+qtl0EDEXEVpuL
ldqK1mDsHwy3bjetu2kICG2WUJkzmTYnI+JJh09k3O32BkKk3bdawISHnqWl
nLxfLNfy2+LM5GBiidTwPWN2ng02Yau/ObOIGN74CfHO3p9UMKp3GMgVgsKN
7U8xDg9vhFuK5lczeXmjnHn9HTtqfCIQsqaDOpjymjEb8+hJha4hMtYWbFQr
0G1a
=tswZ
-----END PGP SIGNATURE-----
",
          "shasum": "d6111b19e89cb4698e39423606a5ed12f901dee6",
          "tarball": "https://registry.npmjs.org/sponsorsme/-/sponsorsme-1.0.0.tgz",
          "unpackedSize": 15939,
        },
        "gitHead": "0c1174e94ea11e44e41bc41481b19ccbe33c82e4",
        "homepage": "https://github.com/maticzav/sponsorsme#readme",
        "license": "MIT",
        "main": "dist/index.js",
        "maintainers": Array [
          Object {
            "email": "matic.zavadlal@gmail.com",
            "name": "maticzav",
          },
        ],
        "name": "sponsorsme",
        "release": Object {
          "branches": Array [
            "main",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/maticzav/sponsorsme.git",
        },
        "scripts": Object {
          "build": "tsc",
          "coverage": "codecov",
          "test": "jest",
        },
        "version": "1.0.0",
      },
      "1.0.1": Object {
        "_hasShrinkwrap": false,
        "_id": "sponsorsme@1.0.1",
        "_nodeVersion": "13.14.0",
        "_npmOperationalInternal": Object {
          "host": "s3://npm-registry-packages",
          "tmp": "tmp/sponsorsme_1.0.1_1606516571553_0.7877385184125669",
        },
        "_npmUser": Object {
          "email": "matic.zavadlal@gmail.com",
          "name": "maticzav",
        },
        "_npmVersion": "6.14.4",
        "author": Object {
          "email": "matic.zavadlal@gmail.com",
          "name": "Matic Zavadlal",
        },
        "bugs": Object {
          "url": "https://github.com/maticzav/sponsorsme/issues",
        },
        "dependencies": Object {
          "@octokit/graphql": "^4.5.7",
        },
        "description": "Lightweight package that lets you see who is sponsoring you.",
        "devDependencies": Object {
          "@types/jest": "26.0.15",
          "@types/node": "14.14.9",
          "codecov": "3.8.1",
          "husky": "4.3.0",
          "jest": "26.6.3",
          "prettier": "2.2.0",
          "pretty-quick": "3.1.0",
          "ts-jest": "26.4.4",
          "ts-node": "9.0.0",
          "typescript": "4.1.2",
        },
        "directories": Object {},
        "dist": Object {
          "fileCount": 9,
          "integrity": "sha512-ZZLBz6giJYfhHb0rLi8EpilSiXCobcinMrKj9oHmobY83mLdUTk+jzgUGp6jrofp1XZ9MUwLtOK5hPbxcU0PYA==",
          "npm-signature": "-----BEGIN PGP SIGNATURE-----
Version: OpenPGP.js v3.0.13
Comment: https://openpgpjs.org

wsFcBAEBCAAQBQJfwX9cCRA9TVsSAnZWagAAqooP/06tllAy9Z/aOgzONfQa
RUiL5JTzidLpviyfq+WV07YS0tE/ZGMLdwHAs77L4T6Or00YT9UGizh+RhhS
2s1RlGrZo5DkOn3zumbCKTBEHfDTcG7eEflw2ctPwijSzY0RhUuJkhQy0kzc
66RLW8uGoU8UclytRiSIj3fPuyBwRV9oqo3xhiYaiaK+VrEc4q7oQhanb//B
WL+2Dtvb1uVzNIinevSAEC1dzuy1yC8lKdyu3edrmb0hdKdNASzpTUakLivV
yz+NICrN2iODIXwxLLZdmBFEU4JQhuvwZVSVVbKum1/C3s9P6kiIZcwYvmww
9lPslyoTyPXaw7w6f+XCgFXIWsWYVzcFWV8vpFdtKiPT51igw0pNjW7k5JLu
1EP2QbUAk2gOY8riUZoEGYd4GlbbfleOglQVgfEf048Ed4j3p+s3yl/H2zCU
A7tYMXBzefHPkP8Eb1aqCJkokWl/kx9BJkGVDhbl/Z97Bl1EdZttdXgbIkT7
6eX1qBB78FMt+g+ur/jYe7IoJ7c6XGKsnH+LYNdIL+VH7gFZ2QCKvIt8Vsae
yBVbGgSHobtTc8DQj2bV3peFCR2lqcXGptr//87BFt/UKZVC0l4RTG3D9qMe
NXauqLy2lDOc7aWoULmBU+J/t/FtoPccwboKbf8MQ7CaSpMm38waPc2/I5dn
J8aW
=LNUJ
-----END PGP SIGNATURE-----
",
          "shasum": "4398495a46de8c4613b0bcfdb2fbeb2a70fff2b7",
          "tarball": "https://registry.npmjs.org/sponsorsme/-/sponsorsme-1.0.1.tgz",
          "unpackedSize": 15930,
        },
        "gitHead": "e38486d3271ddf9134db1f89b51e0c7d21d21813",
        "homepage": "https://github.com/maticzav/sponsorsme#readme",
        "license": "MIT",
        "main": "dist/index.js",
        "maintainers": Array [
          Object {
            "email": "matic.zavadlal@gmail.com",
            "name": "maticzav",
          },
        ],
        "name": "sponsorsme",
        "release": Object {
          "branches": Array [
            "main",
          ],
        },
        "repository": Object {
          "type": "git",
          "url": "git+https://github.com/maticzav/sponsorsme.git",
        },
        "scripts": Object {
          "build": "tsc",
          "coverage": "codecov",
          "test": "jest",
        },
        "version": "1.0.1",
      },
    },
  },
}
`;
