// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`can get EDD from "execa" package 1`] = `
Object {
  "modules": Array [
    Object {
      "isMain": false,
      "kind": "module",
      "location": Object {
        "filePath": "index.d.ts",
      },
      "mainExport": null,
      "name": "index",
      "namedExports": Array [
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "StdioOption",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "CommonOptions",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).CommonOptions<EncodingType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "Options",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).Options<EncodingType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "SyncOptions",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).SyncOptions<EncodingType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "NodeOptions",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).NodeOptions<EncodingType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaReturnBase",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaReturnBase<StdoutStderrType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaSyncReturnValue",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaSyncReturnValue<StdoutErrorType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaReturnValue",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaReturnValue<StdoutErrorType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaSyncError",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaSyncError<StdoutErrorType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaError",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaError<StdoutErrorType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "KillOptions",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).KillOptions",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaChildPromise",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaChildPromise<StdoutErrorType>",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "ExecaChildProcess",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).ExecaChildProcess",
          },
        },
      ],
      "path": "/index",
      "tsdoc": null,
    },
  ],
  "typeIndex": Object {
    "(index).CommonOptions<EncodingType>": Object {
      "kind": "interface",
      "name": "CommonOptions",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "cleanup",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "preferLocal",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "localDir",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "execPath",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "buffer",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdin",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "reject",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stripFinalNewline",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "extendEnv",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "cwd",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "env",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
              "nodeText": "interface ProcessEnv extends Dict<string> {}",
              "typeText": "ProcessEnv",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "argv0",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdio",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"pipe\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"ignore\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"inherit\\"",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "typeText": "readonly StdioOption[]",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "serialization",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"json\\" | \\"advanced\\"",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"json\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"advanced\\"",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "detached",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "uid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "gid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "shell",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | boolean",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "false",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "true",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "encoding",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "EncodingType",
              "nodeText": "EncodingType",
              "typeText": "EncodingType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "timeout",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "maxBuffer",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "killSignal",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | number",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "primitive",
                "type": "number",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsVerbatimArguments",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsHide",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface CommonOptions<EncodingType> {
		/**
		Kill the spawned process when the parent process exits unless either:
			- the spawned process is [\`detached\`](https://nodejs.org/api/child_process.html#child_process_options_detached)
			- the parent process is terminated abruptly, for example, with \`SIGKILL\` as opposed to \`SIGTERM\` or a normal exit

		@default true
		*/
		readonly cleanup?: boolean;

		/**
		Prefer locally installed binaries when looking for a binary to execute.

		If you \`$ npm install foo\`, you can then \`execa('foo')\`.

		@default false
		*/
		readonly preferLocal?: boolean;

		/**
		Preferred path to find locally installed binaries in (use with \`preferLocal\`).

		@default process.cwd()
		*/
		readonly localDir?: string;

		/**
		Path to the Node.js executable to use in child processes.

		This can be either an absolute path or a path relative to the \`cwd\` option.

		Requires \`preferLocal\` to be \`true\`.

		For example, this can be used together with [\`get-node\`](https://github.com/ehmicky/get-node) to run a specific Node.js version in a child process.

		@default process.execPath
		*/
		readonly execPath?: string;

		/**
		Buffer the output from the spawned process. When set to \`false\`, you must read the output of \`stdout\` and \`stderr\` (or \`all\` if the \`all\` option is \`true\`). Otherwise the returned promise will not be resolved/rejected.

		If the spawned process fails, \`error.stdout\`, \`error.stderr\`, and \`error.all\` will contain the buffered data.

		@default true
		*/
		readonly buffer?: boolean;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdin?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdout?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stderr?: StdioOption;

		/**
		Setting this to \`false\` resolves the promise with the error instead of rejecting it.

		@default true
		*/
		readonly reject?: boolean;

		/**
		Add an \`.all\` property on the promise and the resolved value. The property contains the output of the process with \`stdout\` and \`stderr\` interleaved.

		@default false
		*/
		readonly all?: boolean;

		/**
		Strip the final [newline character](https://en.wikipedia.org/wiki/Newline) from the output.

		@default true
		*/
		readonly stripFinalNewline?: boolean;

		/**
		Set to \`false\` if you don't want to extend the environment variables when providing the \`env\` property.

		@default true
		*/
		readonly extendEnv?: boolean;

		/**
		Current working directory of the child process.

		@default process.cwd()
		*/
		readonly cwd?: string;

		/**
		Environment key-value pairs. Extends automatically from \`process.env\`. Set \`extendEnv\` to \`false\` if you don't want this.

		@default process.env
		*/
		readonly env?: NodeJS.ProcessEnv;

		/**
		Explicitly set the value of \`argv[0]\` sent to the child process. This will be set to \`command\` or \`file\` if not specified.
		*/
		readonly argv0?: string;

		/**
		Child's [stdio](https://nodejs.org/api/child_process.html#child_process_options_stdio) configuration.

		@default 'pipe'
		*/
		readonly stdio?: 'pipe' | 'ignore' | 'inherit' | readonly StdioOption[];

		/**
		Specify the kind of serialization used for sending messages between processes when using the \`stdio: 'ipc'\` option or \`execa.node()\`:
			- \`json\`: Uses \`JSON.stringify()\` and \`JSON.parse()\`.
			- \`advanced\`: Uses [\`v8.serialize()\`](https://nodejs.org/api/v8.html#v8_v8_serialize_value)

		Requires Node.js \`13.2.0\` or later.

		[More info.](https://nodejs.org/api/child_process.html#child_process_advanced_serialization)

		@default 'json'
		*/
		readonly serialization?: 'json' | 'advanced';

		/**
		Prepare child to run independently of its parent process. Specific behavior [depends on the platform](https://nodejs.org/api/child_process.html#child_process_options_detached).

		@default false
		*/
		readonly detached?: boolean;

		/**
		Sets the user identity of the process.
		*/
		readonly uid?: number;

		/**
		Sets the group identity of the process.
		*/
		readonly gid?: number;

		/**
		If \`true\`, runs \`command\` inside of a shell. Uses \`/bin/sh\` on UNIX and \`cmd.exe\` on Windows. A different shell can be specified as a string. The shell should understand the \`-c\` switch on UNIX or \`/d /s /c\` on Windows.

		We recommend against using this option since it is:
		- not cross-platform, encouraging shell-specific syntax.
		- slower, because of the additional shell interpretation.
		- unsafe, potentially allowing command injection.

		@default false
		*/
		readonly shell?: boolean | string;

		/**
		Specify the character encoding used to decode the \`stdout\` and \`stderr\` output. If set to \`null\`, then \`stdout\` and \`stderr\` will be a \`Buffer\` instead of a string.

		@default 'utf8'
		*/
		readonly encoding?: EncodingType;

		/**
		If \`timeout\` is greater than \`0\`, the parent will send the signal identified by the \`killSignal\` property (the default is \`SIGTERM\`) if the child runs longer than \`timeout\` milliseconds.

		@default 0
		*/
		readonly timeout?: number;

		/**
		Largest amount of data in bytes allowed on \`stdout\` or \`stderr\`. Default: 100 MB.

		@default 100_000_000
		*/
		readonly maxBuffer?: number;

		/**
		Signal value to be used when the spawned process will be killed.

		@default 'SIGTERM'
		*/
		readonly killSignal?: string | number;

		/**
		If \`true\`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to \`true\` automatically when the \`shell\` option is \`true\`.

		@default false
		*/
		readonly windowsVerbatimArguments?: boolean;

		/**
		On Windows, do not create a new console window. Please note this also prevents \`CTRL-C\` [from working](https://github.com/nodejs/node/issues/29837) on Windows.

		@default true
		*/
		readonly windowsHide?: boolean;
	}",
        "nodeText": "interface CommonOptions<EncodingType> {
		/**
		Kill the spawned process when the parent process exits unless either:
			- the spawned process is [\`detached\`](https://nodejs.org/api/child_process.html#child_process_options_detached)
			- the parent process is terminated abruptly, for example, with \`SIGKILL\` as opposed to \`SIGTERM\` or a normal exit

		@default true
		*/
		readonly cleanup?: boolean;

		/**
		Prefer locally installed binaries when looking for a binary to execute.

		If you \`$ npm install foo\`, you can then \`execa('foo')\`.

		@default false
		*/
		readonly preferLocal?: boolean;

		/**
		Preferred path to find locally installed binaries in (use with \`preferLocal\`).

		@default process.cwd()
		*/
		readonly localDir?: string;

		/**
		Path to the Node.js executable to use in child processes.

		This can be either an absolute path or a path relative to the \`cwd\` option.

		Requires \`preferLocal\` to be \`true\`.

		For example, this can be used together with [\`get-node\`](https://github.com/ehmicky/get-node) to run a specific Node.js version in a child process.

		@default process.execPath
		*/
		readonly execPath?: string;

		/**
		Buffer the output from the spawned process. When set to \`false\`, you must read the output of \`stdout\` and \`stderr\` (or \`all\` if the \`all\` option is \`true\`). Otherwise the returned promise will not be resolved/rejected.

		If the spawned process fails, \`error.stdout\`, \`error.stderr\`, and \`error.all\` will contain the buffered data.

		@default true
		*/
		readonly buffer?: boolean;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdin?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stdout?: StdioOption;

		/**
		Same options as [\`stdio\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).

		@default 'pipe'
		*/
		readonly stderr?: StdioOption;

		/**
		Setting this to \`false\` resolves the promise with the error instead of rejecting it.

		@default true
		*/
		readonly reject?: boolean;

		/**
		Add an \`.all\` property on the promise and the resolved value. The property contains the output of the process with \`stdout\` and \`stderr\` interleaved.

		@default false
		*/
		readonly all?: boolean;

		/**
		Strip the final [newline character](https://en.wikipedia.org/wiki/Newline) from the output.

		@default true
		*/
		readonly stripFinalNewline?: boolean;

		/**
		Set to \`false\` if you don't want to extend the environment variables when providing the \`env\` property.

		@default true
		*/
		readonly extendEnv?: boolean;

		/**
		Current working directory of the child process.

		@default process.cwd()
		*/
		readonly cwd?: string;

		/**
		Environment key-value pairs. Extends automatically from \`process.env\`. Set \`extendEnv\` to \`false\` if you don't want this.

		@default process.env
		*/
		readonly env?: NodeJS.ProcessEnv;

		/**
		Explicitly set the value of \`argv[0]\` sent to the child process. This will be set to \`command\` or \`file\` if not specified.
		*/
		readonly argv0?: string;

		/**
		Child's [stdio](https://nodejs.org/api/child_process.html#child_process_options_stdio) configuration.

		@default 'pipe'
		*/
		readonly stdio?: 'pipe' | 'ignore' | 'inherit' | readonly StdioOption[];

		/**
		Specify the kind of serialization used for sending messages between processes when using the \`stdio: 'ipc'\` option or \`execa.node()\`:
			- \`json\`: Uses \`JSON.stringify()\` and \`JSON.parse()\`.
			- \`advanced\`: Uses [\`v8.serialize()\`](https://nodejs.org/api/v8.html#v8_v8_serialize_value)

		Requires Node.js \`13.2.0\` or later.

		[More info.](https://nodejs.org/api/child_process.html#child_process_advanced_serialization)

		@default 'json'
		*/
		readonly serialization?: 'json' | 'advanced';

		/**
		Prepare child to run independently of its parent process. Specific behavior [depends on the platform](https://nodejs.org/api/child_process.html#child_process_options_detached).

		@default false
		*/
		readonly detached?: boolean;

		/**
		Sets the user identity of the process.
		*/
		readonly uid?: number;

		/**
		Sets the group identity of the process.
		*/
		readonly gid?: number;

		/**
		If \`true\`, runs \`command\` inside of a shell. Uses \`/bin/sh\` on UNIX and \`cmd.exe\` on Windows. A different shell can be specified as a string. The shell should understand the \`-c\` switch on UNIX or \`/d /s /c\` on Windows.

		We recommend against using this option since it is:
		- not cross-platform, encouraging shell-specific syntax.
		- slower, because of the additional shell interpretation.
		- unsafe, potentially allowing command injection.

		@default false
		*/
		readonly shell?: boolean | string;

		/**
		Specify the character encoding used to decode the \`stdout\` and \`stderr\` output. If set to \`null\`, then \`stdout\` and \`stderr\` will be a \`Buffer\` instead of a string.

		@default 'utf8'
		*/
		readonly encoding?: EncodingType;

		/**
		If \`timeout\` is greater than \`0\`, the parent will send the signal identified by the \`killSignal\` property (the default is \`SIGTERM\`) if the child runs longer than \`timeout\` milliseconds.

		@default 0
		*/
		readonly timeout?: number;

		/**
		Largest amount of data in bytes allowed on \`stdout\` or \`stderr\`. Default: 100 MB.

		@default 100_000_000
		*/
		readonly maxBuffer?: number;

		/**
		Signal value to be used when the spawned process will be killed.

		@default 'SIGTERM'
		*/
		readonly killSignal?: string | number;

		/**
		If \`true\`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to \`true\` automatically when the \`shell\` option is \`true\`.

		@default false
		*/
		readonly windowsVerbatimArguments?: boolean;

		/**
		On Windows, do not create a new console window. Please note this also prevents \`CTRL-C\` [from working](https://github.com/nodejs/node/issues/29837) on Windows.

		@default true
		*/
		readonly windowsHide?: boolean;
	}",
        "typeText": "CommonOptions<EncodingType>",
      },
      "tsdoc": null,
    },
    "(index).ExecaChildProcess": Object {
      "kind": "alias",
      "name": "ExecaChildProcess",
      "raw": Object {
        "nodeFullText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
        "nodeText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
        "typeText": "ExecaChildProcess<StdoutErrorType>",
      },
      "tsdoc": null,
      "type": Object {
        "kind": "intersection",
        "raw": Object {
          "nodeFullText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
          "nodeText": "type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
		ExecaChildPromise<StdoutErrorType> &
		Promise<ExecaReturnValue<StdoutErrorType>>;",
          "typeText": "ExecaChildProcess<StdoutErrorType>",
        },
        "types": Array [
          Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "interface ChildProcess extends events.EventEmitter {
        stdin: Writable | null;
        stdout: Readable | null;
        stderr: Readable | null;
        readonly channel?: Pipe | null;
        readonly stdio: [
            Writable | null, // stdin
            Readable | null, // stdout
            Readable | null, // stderr
            Readable | Writable | null | undefined, // extra
            Readable | Writable | null | undefined // extra
        ];
        readonly killed: boolean;
        readonly pid: number;
        readonly connected: boolean;
        readonly exitCode: number | null;
        readonly signalCode: NodeJS.Signals | null;
        readonly spawnargs: string[];
        readonly spawnfile: string;
        kill(signal?: NodeJS.Signals | number): boolean;
        send(message: Serializable, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, options?: MessageOptions, callback?: (error: Error | null) => void): boolean;
        disconnect(): void;
        unref(): void;
        ref(): void;

        /**
         * events.EventEmitter
         * 1. close
         * 2. disconnect
         * 3. error
         * 4. exit
         * 5. message
         */

        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        addListener(event: \\"disconnect\\", listener: () => void): this;
        addListener(event: \\"error\\", listener: (err: Error) => void): this;
        addListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: \\"close\\", code: number, signal: NodeJS.Signals): boolean;
        emit(event: \\"disconnect\\"): boolean;
        emit(event: \\"error\\", err: Error): boolean;
        emit(event: \\"exit\\", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: \\"message\\", message: Serializable, sendHandle: SendHandle): boolean;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        on(event: \\"disconnect\\", listener: () => void): this;
        on(event: \\"error\\", listener: (err: Error) => void): this;
        on(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        once(event: \\"disconnect\\", listener: () => void): this;
        once(event: \\"error\\", listener: (err: Error) => void): this;
        once(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependListener(event: \\"disconnect\\", listener: () => void): this;
        prependListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependOnceListener(event: \\"disconnect\\", listener: () => void): this;
        prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependOnceListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependOnceListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
    }",
              "nodeText": "interface ChildProcess extends events.EventEmitter {
        stdin: Writable | null;
        stdout: Readable | null;
        stderr: Readable | null;
        readonly channel?: Pipe | null;
        readonly stdio: [
            Writable | null, // stdin
            Readable | null, // stdout
            Readable | null, // stderr
            Readable | Writable | null | undefined, // extra
            Readable | Writable | null | undefined // extra
        ];
        readonly killed: boolean;
        readonly pid: number;
        readonly connected: boolean;
        readonly exitCode: number | null;
        readonly signalCode: NodeJS.Signals | null;
        readonly spawnargs: string[];
        readonly spawnfile: string;
        kill(signal?: NodeJS.Signals | number): boolean;
        send(message: Serializable, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, options?: MessageOptions, callback?: (error: Error | null) => void): boolean;
        disconnect(): void;
        unref(): void;
        ref(): void;

        /**
         * events.EventEmitter
         * 1. close
         * 2. disconnect
         * 3. error
         * 4. exit
         * 5. message
         */

        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        addListener(event: \\"disconnect\\", listener: () => void): this;
        addListener(event: \\"error\\", listener: (err: Error) => void): this;
        addListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: \\"close\\", code: number, signal: NodeJS.Signals): boolean;
        emit(event: \\"disconnect\\"): boolean;
        emit(event: \\"error\\", err: Error): boolean;
        emit(event: \\"exit\\", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: \\"message\\", message: Serializable, sendHandle: SendHandle): boolean;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        on(event: \\"disconnect\\", listener: () => void): this;
        on(event: \\"error\\", listener: (err: Error) => void): this;
        on(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        once(event: \\"disconnect\\", listener: () => void): this;
        once(event: \\"error\\", listener: (err: Error) => void): this;
        once(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependListener(event: \\"disconnect\\", listener: () => void): this;
        prependListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: \\"close\\", listener: (code: number, signal: NodeJS.Signals) => void): this;
        prependOnceListener(event: \\"disconnect\\", listener: () => void): this;
        prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
        prependOnceListener(event: \\"exit\\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependOnceListener(event: \\"message\\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
    }",
              "typeText": "ChildProcess",
            },
          },
          Object {
            "kind": "object",
            "props": Array [
              Object {
                "kind": "prop",
                "name": "catch",
                "type": Object {
                  "hasProps": false,
                  "isOverloaded": false,
                  "kind": "callable",
                  "props": Array [],
                  "raw": Object {
                    "nodeFullText": "catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;",
                    "nodeText": "catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;",
                    "typeText": "<ResultType = never>(onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>) => Promise<ResultType | ExecaReturnValue<...>>",
                  },
                  "sigs": Array [
                    Object {
                      "kind": "sig",
                      "params": Array [
                        Object {
                          "kind": "sigParam",
                          "name": "onRejected",
                          "type": Object {
                            "hasProps": false,
                            "isOverloaded": false,
                            "kind": "callable",
                            "props": Array [],
                            "raw": Object {
                              "nodeFullText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                              "nodeText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                              "typeText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                            },
                            "sigs": Array [
                              Object {
                                "kind": "sig",
                                "params": Array [
                                  Object {
                                    "kind": "sigParam",
                                    "name": "reason",
                                    "type": Object {
                                      "kind": "object",
                                      "props": Array [
                                        Object {
                                          "kind": "prop",
                                          "name": "all",
                                          "type": Object {
                                            "kind": "unsupported",
                                            "raw": Object {
                                              "nodeFullText": "StdoutErrorType = string",
                                              "nodeText": "StdoutErrorType = string",
                                              "typeText": "StdoutErrorType",
                                            },
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "isCanceled",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "boolean",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "message",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "shortMessage",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "originalMessage",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "name",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "stack",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "command",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "exitCode",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "number",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "stdout",
                                          "type": Object {
                                            "kind": "unsupported",
                                            "raw": Object {
                                              "nodeFullText": "StdoutStderrType",
                                              "nodeText": "StdoutStderrType",
                                              "typeText": "StdoutStderrType",
                                            },
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "stderr",
                                          "type": Object {
                                            "kind": "unsupported",
                                            "raw": Object {
                                              "nodeFullText": "StdoutStderrType",
                                              "nodeText": "StdoutStderrType",
                                              "typeText": "StdoutStderrType",
                                            },
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "failed",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "boolean",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "timedOut",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "boolean",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "killed",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "boolean",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "signal",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                        Object {
                                          "kind": "prop",
                                          "name": "signalDescription",
                                          "type": Object {
                                            "kind": "primitive",
                                            "type": "string",
                                          },
                                        },
                                      ],
                                      "raw": Object {
                                        "nodeFullText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                                        "nodeText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                                        "typeText": "ExecaError<StdoutErrorType>",
                                      },
                                    },
                                  },
                                ],
                                "return": Object {
                                  "discriminantProperties": null,
                                  "isDiscriminated": false,
                                  "kind": "union",
                                  "raw": Object {
                                    "nodeFullText": "",
                                    "nodeText": "",
                                    "typeText": "ResultType | PromiseLike<ResultType>",
                                  },
                                  "types": Array [
                                    Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "ResultType = never",
                                        "nodeText": "ResultType = never",
                                        "typeText": "ResultType",
                                      },
                                    },
                                    Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                        "nodeText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                        "typeText": "PromiseLike<ResultType>",
                                      },
                                    },
                                  ],
                                },
                              },
                            ],
                          },
                        },
                      ],
                      "return": Object {
                        "kind": "unsupported",
                        "raw": Object {
                          "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                          "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                          "typeText": "Promise<ResultType | ExecaReturnValue<StdoutErrorType>>",
                        },
                      },
                    },
                  ],
                },
              },
              Object {
                "kind": "prop",
                "name": "kill",
                "type": Object {
                  "hasProps": false,
                  "isOverloaded": false,
                  "kind": "callable",
                  "props": Array [],
                  "raw": Object {
                    "nodeFullText": "/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;",
                    "nodeText": "kill(signal?: string, options?: execa.KillOptions): void;",
                    "typeText": "(signal?: string, options?: KillOptions) => void",
                  },
                  "sigs": Array [
                    Object {
                      "kind": "sig",
                      "params": Array [
                        Object {
                          "kind": "sigParam",
                          "name": "signal",
                          "type": Object {
                            "kind": "primitive",
                            "type": "string",
                          },
                        },
                        Object {
                          "kind": "sigParam",
                          "name": "options",
                          "type": Object {
                            "kind": "typeIndexRef",
                            "link": "(index).KillOptions",
                          },
                        },
                      ],
                      "return": Object {
                        "kind": "primitive",
                        "type": "void",
                      },
                    },
                  ],
                },
              },
              Object {
                "kind": "prop",
                "name": "cancel",
                "type": Object {
                  "hasProps": false,
                  "isOverloaded": false,
                  "kind": "callable",
                  "props": Array [],
                  "raw": Object {
                    "nodeFullText": "/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;",
                    "nodeText": "cancel(): void;",
                    "typeText": "() => void",
                  },
                  "sigs": Array [
                    Object {
                      "kind": "sig",
                      "params": Array [],
                      "return": Object {
                        "kind": "primitive",
                        "type": "void",
                      },
                    },
                  ],
                },
              },
              Object {
                "kind": "prop",
                "name": "all",
                "type": Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                    "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                    "typeText": "Readable",
                  },
                },
              },
            ],
            "raw": Object {
              "nodeFullText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
              "nodeText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
              "typeText": "ExecaChildPromise<StdoutErrorType>",
            },
          },
          Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
              "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
              "typeText": "Promise<ExecaReturnValue<StdoutErrorType>>",
            },
          },
        ],
      },
    },
    "(index).ExecaChildPromise<StdoutErrorType>": Object {
      "kind": "interface",
      "name": "ExecaChildPromise",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "catch",
          "type": Object {
            "hasProps": false,
            "isOverloaded": false,
            "kind": "callable",
            "props": Array [],
            "raw": Object {
              "nodeFullText": "catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;",
              "nodeText": "catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;",
              "typeText": "<ResultType = never>(onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>) => Promise<ResultType | ExecaReturnValue<...>>",
            },
            "sigs": Array [
              Object {
                "kind": "sig",
                "params": Array [
                  Object {
                    "kind": "sigParam",
                    "name": "onRejected",
                    "type": Object {
                      "hasProps": false,
                      "isOverloaded": false,
                      "kind": "callable",
                      "props": Array [],
                      "raw": Object {
                        "nodeFullText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                        "nodeText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                        "typeText": "(reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>",
                      },
                      "sigs": Array [
                        Object {
                          "kind": "sig",
                          "params": Array [
                            Object {
                              "kind": "sigParam",
                              "name": "reason",
                              "type": Object {
                                "kind": "object",
                                "props": Array [
                                  Object {
                                    "kind": "prop",
                                    "name": "all",
                                    "type": Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "StdoutErrorType = string",
                                        "nodeText": "StdoutErrorType = string",
                                        "typeText": "StdoutErrorType",
                                      },
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "isCanceled",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "boolean",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "message",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "shortMessage",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "originalMessage",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "name",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "stack",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "command",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "exitCode",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "number",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "stdout",
                                    "type": Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "StdoutStderrType",
                                        "nodeText": "StdoutStderrType",
                                        "typeText": "StdoutStderrType",
                                      },
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "stderr",
                                    "type": Object {
                                      "kind": "unsupported",
                                      "raw": Object {
                                        "nodeFullText": "StdoutStderrType",
                                        "nodeText": "StdoutStderrType",
                                        "typeText": "StdoutStderrType",
                                      },
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "failed",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "boolean",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "timedOut",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "boolean",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "killed",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "boolean",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "signal",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                  Object {
                                    "kind": "prop",
                                    "name": "signalDescription",
                                    "type": Object {
                                      "kind": "primitive",
                                      "type": "string",
                                    },
                                  },
                                ],
                                "raw": Object {
                                  "nodeFullText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                                  "nodeText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
                                  "typeText": "ExecaError<StdoutErrorType>",
                                },
                              },
                            },
                          ],
                          "return": Object {
                            "discriminantProperties": null,
                            "isDiscriminated": false,
                            "kind": "union",
                            "raw": Object {
                              "nodeFullText": "",
                              "nodeText": "",
                              "typeText": "ResultType | PromiseLike<ResultType>",
                            },
                            "types": Array [
                              Object {
                                "kind": "unsupported",
                                "raw": Object {
                                  "nodeFullText": "ResultType = never",
                                  "nodeText": "ResultType = never",
                                  "typeText": "ResultType",
                                },
                              },
                              Object {
                                "kind": "unsupported",
                                "raw": Object {
                                  "nodeFullText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                  "nodeText": "interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}",
                                  "typeText": "PromiseLike<ResultType>",
                                },
                              },
                            ],
                          },
                        },
                      ],
                    },
                  },
                ],
                "return": Object {
                  "kind": "unsupported",
                  "raw": Object {
                    "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                    "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                    "typeText": "Promise<ResultType | ExecaReturnValue<StdoutErrorType>>",
                  },
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "kill",
          "type": Object {
            "hasProps": false,
            "isOverloaded": false,
            "kind": "callable",
            "props": Array [],
            "raw": Object {
              "nodeFullText": "/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;",
              "nodeText": "kill(signal?: string, options?: execa.KillOptions): void;",
              "typeText": "(signal?: string, options?: KillOptions) => void",
            },
            "sigs": Array [
              Object {
                "kind": "sig",
                "params": Array [
                  Object {
                    "kind": "sigParam",
                    "name": "signal",
                    "type": Object {
                      "kind": "primitive",
                      "type": "string",
                    },
                  },
                  Object {
                    "kind": "sigParam",
                    "name": "options",
                    "type": Object {
                      "kind": "typeIndexRef",
                      "link": "(index).KillOptions",
                    },
                  },
                ],
                "return": Object {
                  "kind": "primitive",
                  "type": "void",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "cancel",
          "type": Object {
            "hasProps": false,
            "isOverloaded": false,
            "kind": "callable",
            "props": Array [],
            "raw": Object {
              "nodeFullText": "/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;",
              "nodeText": "cancel(): void;",
              "typeText": "() => void",
            },
            "sigs": Array [
              Object {
                "kind": "sig",
                "params": Array [],
                "return": Object {
                  "kind": "primitive",
                  "type": "void",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
              "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
              "typeText": "Readable",
            },
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
        "nodeText": "interface ExecaChildPromise<StdoutErrorType> {
		catch<ResultType = never>(
			onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
		): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;

		/**
		Same as the original [\`child_process#kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if \`signal\` is \`SIGTERM\` (the default value) and the child process is not terminated after 5 seconds, force it by sending \`SIGKILL\`.
		*/
		kill(signal?: string, options?: execa.KillOptions): void;

		/**
		Similar to [\`childProcess.kill()\`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This is preferred when cancelling the child process execution as the error is more descriptive and [\`childProcessResult.isCanceled\`](#iscanceled) is set to \`true\`.
		*/
		cancel(): void;

		/**
		Stream combining/interleaving [\`stdout\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [\`stderr\`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).

		This is \`undefined\` if either:
			- the \`all\` option is \`false\` (the default value)
			- both \`stdout\` and \`stderr\` options are set to [\`'inherit'\`, \`'ipc'\`, \`Stream\` or \`integer\`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
		*/
		all?: ReadableStream;
	}",
        "typeText": "ExecaChildPromise<StdoutErrorType>",
      },
      "tsdoc": null,
    },
    "(index).ExecaError<StdoutErrorType>": Object {
      "kind": "interface",
      "name": "ExecaError",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "isCanceled",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "message",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "shortMessage",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "originalMessage",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "name",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "stack",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "command",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "exitCode",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "failed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "timedOut",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "killed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "signal",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "signalDescription",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
        "nodeText": "interface ExecaError<StdoutErrorType = string>
		extends ExecaSyncError<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
        "typeText": "ExecaError<StdoutErrorType>",
      },
      "tsdoc": null,
    },
    "(index).ExecaReturnBase<StdoutStderrType>": Object {
      "kind": "interface",
      "name": "ExecaReturnBase",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "command",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "exitCode",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "failed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "timedOut",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "killed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "signal",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "signalDescription",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface ExecaReturnBase<StdoutStderrType> {
		/**
		The file and arguments that were run.
		*/
		command: string;

		/**
		The numeric exit code of the process that was run.
		*/
		exitCode: number;

		/**
		The output of the process on stdout.
		*/
		stdout: StdoutStderrType;

		/**
		The output of the process on stderr.
		*/
		stderr: StdoutStderrType;

		/**
		Whether the process failed to run.
		*/
		failed: boolean;

		/**
		Whether the process timed out.
		*/
		timedOut: boolean;

		/**
		Whether the process was killed.
		*/
		killed: boolean;

		/**
		The name of the signal that was used to terminate the process. For example, \`SIGFPE\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`.
		*/
		signal?: string;

		/**
		A human-friendly description of the signal that was used to terminate the process. For example, \`Floating point arithmetic error\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`. It is also \`undefined\` when the signal is very uncommon which should seldomly happen.
		*/
		signalDescription?: string;
	}",
        "nodeText": "interface ExecaReturnBase<StdoutStderrType> {
		/**
		The file and arguments that were run.
		*/
		command: string;

		/**
		The numeric exit code of the process that was run.
		*/
		exitCode: number;

		/**
		The output of the process on stdout.
		*/
		stdout: StdoutStderrType;

		/**
		The output of the process on stderr.
		*/
		stderr: StdoutStderrType;

		/**
		Whether the process failed to run.
		*/
		failed: boolean;

		/**
		Whether the process timed out.
		*/
		timedOut: boolean;

		/**
		Whether the process was killed.
		*/
		killed: boolean;

		/**
		The name of the signal that was used to terminate the process. For example, \`SIGFPE\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`.
		*/
		signal?: string;

		/**
		A human-friendly description of the signal that was used to terminate the process. For example, \`Floating point arithmetic error\`.

		If a signal terminated the process, this property is defined and included in the error message. Otherwise it is \`undefined\`. It is also \`undefined\` when the signal is very uncommon which should seldomly happen.
		*/
		signalDescription?: string;
	}",
        "typeText": "ExecaReturnBase<StdoutStderrType>",
      },
      "tsdoc": null,
    },
    "(index).ExecaReturnValue<StdoutErrorType>": Object {
      "kind": "interface",
      "name": "ExecaReturnValue",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutErrorType = string",
              "nodeText": "StdoutErrorType = string",
              "typeText": "StdoutErrorType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "isCanceled",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "command",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "exitCode",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "failed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "timedOut",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "killed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "signal",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "signalDescription",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "/**
	Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes
	*/
	interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
        "nodeText": "interface ExecaReturnValue<StdoutErrorType = string>
		extends ExecaSyncReturnValue<StdoutErrorType> {
		/**
		The output of the process with \`stdout\` and \`stderr\` interleaved.

		This is \`undefined\` if either:
		- the \`all\` option is \`false\` (default value)
		- \`execa.sync()\` was used
		*/
		all?: StdoutErrorType;

		/**
		Whether the process was canceled.
		*/
		isCanceled: boolean;
	}",
        "typeText": "ExecaReturnValue<StdoutErrorType>",
      },
      "tsdoc": Object {
        "customTags": Array [],
        "examples": Array [],
        "raw": "/**
	Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes
	*/",
        "summary": "Result of a child process execution. On success this is a plain object. On failure this is also an \`Error\` instance.

	The child process fails when:
	- its exit code is not \`0\`
	- it was killed with a signal
	- timing out
	- being canceled
	- there's not enough memory or there are already too many child processes",
      },
    },
    "(index).ExecaSyncError<StdoutErrorType>": Object {
      "kind": "interface",
      "name": "ExecaSyncError",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "message",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "shortMessage",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "originalMessage",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "name",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "stack",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "command",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "exitCode",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "failed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "timedOut",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "killed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "signal",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "signalDescription",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface ExecaSyncError<StdoutErrorType = string>
		extends Error,
			ExecaReturnBase<StdoutErrorType> {
		/**
		Error message when the child process failed to run. In addition to the underlying error message, it also contains some information related to why the child process errored.

		The child process stderr then stdout are appended to the end, separated with newlines and not interleaved.
		*/
		message: string;

		/**
		This is the same as the \`message\` property except it does not include the child process stdout/stderr.
		*/
		shortMessage: string;

		/**
		Original error message. This is the same as the \`message\` property except it includes neither the child process stdout/stderr nor some additional information added by Execa.

		This is \`undefined\` unless the child process exited due to an \`error\` event or a timeout.
		*/
		originalMessage?: string;
	}",
        "nodeText": "interface ExecaSyncError<StdoutErrorType = string>
		extends Error,
			ExecaReturnBase<StdoutErrorType> {
		/**
		Error message when the child process failed to run. In addition to the underlying error message, it also contains some information related to why the child process errored.

		The child process stderr then stdout are appended to the end, separated with newlines and not interleaved.
		*/
		message: string;

		/**
		This is the same as the \`message\` property except it does not include the child process stdout/stderr.
		*/
		shortMessage: string;

		/**
		Original error message. This is the same as the \`message\` property except it includes neither the child process stdout/stderr nor some additional information added by Execa.

		This is \`undefined\` unless the child process exited due to an \`error\` event or a timeout.
		*/
		originalMessage?: string;
	}",
        "typeText": "ExecaSyncError<StdoutErrorType>",
      },
      "tsdoc": null,
    },
    "(index).ExecaSyncReturnValue<StdoutErrorType>": Object {
      "kind": "interface",
      "name": "ExecaSyncReturnValue",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "command",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "exitCode",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "StdoutStderrType",
              "nodeText": "StdoutStderrType",
              "typeText": "StdoutStderrType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "failed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "timedOut",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "killed",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "signal",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "signalDescription",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface ExecaSyncReturnValue<StdoutErrorType = string>
		extends ExecaReturnBase<StdoutErrorType> {
	}",
        "nodeText": "interface ExecaSyncReturnValue<StdoutErrorType = string>
		extends ExecaReturnBase<StdoutErrorType> {
	}",
        "typeText": "ExecaSyncReturnValue<StdoutErrorType>",
      },
      "tsdoc": null,
    },
    "(index).KillOptions": Object {
      "kind": "interface",
      "name": "KillOptions",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "forceKillAfterTimeout",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "number | false",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "number",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "false",
              },
            ],
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface KillOptions {
		/**
		Milliseconds to wait for the child process to terminate before sending \`SIGKILL\`.

		Can be disabled with \`false\`.

		@default 5000
		*/
		forceKillAfterTimeout?: number | false;
	}",
        "nodeText": "interface KillOptions {
		/**
		Milliseconds to wait for the child process to terminate before sending \`SIGKILL\`.

		Can be disabled with \`false\`.

		@default 5000
		*/
		forceKillAfterTimeout?: number | false;
	}",
        "typeText": "KillOptions",
      },
      "tsdoc": null,
    },
    "(index).NodeOptions<EncodingType>": Object {
      "kind": "interface",
      "name": "NodeOptions",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "nodePath",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "nodeOptions",
          "type": Object {
            "innerType": Object {
              "kind": "primitive",
              "type": "string",
            },
            "kind": "array",
          },
        },
        Object {
          "kind": "prop",
          "name": "input",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | Buffer | Readable",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/**
 * Raw data is stored in instances of the Buffer class.
 * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
 * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
 */
declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                  "nodeText": "declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                  "typeText": "Buffer",
                },
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                  "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                  "typeText": "Readable",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "cleanup",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "preferLocal",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "localDir",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "execPath",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "buffer",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdin",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "reject",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stripFinalNewline",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "extendEnv",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "cwd",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "env",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
              "nodeText": "interface ProcessEnv extends Dict<string> {}",
              "typeText": "ProcessEnv",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "argv0",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdio",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"pipe\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"ignore\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"inherit\\"",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "typeText": "readonly StdioOption[]",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "serialization",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"json\\" | \\"advanced\\"",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"json\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"advanced\\"",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "detached",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "uid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "gid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "shell",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | boolean",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "false",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "true",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "encoding",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "EncodingType",
              "nodeText": "EncodingType",
              "typeText": "EncodingType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "timeout",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "maxBuffer",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "killSignal",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | number",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "primitive",
                "type": "number",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsVerbatimArguments",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsHide",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface NodeOptions<EncodingType = string> extends Options<EncodingType> {
		/**
		The Node.js executable to use.

		@default process.execPath
		*/
		readonly nodePath?: string;

		/**
		List of [CLI options](https://nodejs.org/api/cli.html#cli_options) passed to the Node.js executable.

		@default process.execArgv
		*/
		readonly nodeOptions?: string[];
	}",
        "nodeText": "interface NodeOptions<EncodingType = string> extends Options<EncodingType> {
		/**
		The Node.js executable to use.

		@default process.execPath
		*/
		readonly nodePath?: string;

		/**
		List of [CLI options](https://nodejs.org/api/cli.html#cli_options) passed to the Node.js executable.

		@default process.execArgv
		*/
		readonly nodeOptions?: string[];
	}",
        "typeText": "NodeOptions<EncodingType>",
      },
      "tsdoc": null,
    },
    "(index).Options<EncodingType>": Object {
      "kind": "interface",
      "name": "Options",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "input",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | Buffer | Readable",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/**
 * Raw data is stored in instances of the Buffer class.
 * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
 * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
 */
declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                  "nodeText": "declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                  "typeText": "Buffer",
                },
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                  "nodeText": "class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;

            readable: boolean;
            readonly readableEncoding: BufferEncoding | null;
            readonly readableEnded: boolean;
            readonly readableFlowing: boolean | null;
            readonly readableHighWaterMark: number;
            readonly readableLength: number;
            readonly readableObjectMode: boolean;
            destroyed: boolean;
            constructor(opts?: ReadableOptions);
            _read(size: number): void;
            read(size?: number): any;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            unpipe(destination?: NodeJS.WritableStream): this;
            unshift(chunk: any, encoding?: BufferEncoding): void;
            wrap(oldStream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            destroy(error?: Error): void;

            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: \\"close\\", listener: () => void): this;
            addListener(event: \\"data\\", listener: (chunk: any) => void): this;
            addListener(event: \\"end\\", listener: () => void): this;
            addListener(event: \\"error\\", listener: (err: Error) => void): this;
            addListener(event: \\"pause\\", listener: () => void): this;
            addListener(event: \\"readable\\", listener: () => void): this;
            addListener(event: \\"resume\\", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;

            emit(event: \\"close\\"): boolean;
            emit(event: \\"data\\", chunk: any): boolean;
            emit(event: \\"end\\"): boolean;
            emit(event: \\"error\\", err: Error): boolean;
            emit(event: \\"pause\\"): boolean;
            emit(event: \\"readable\\"): boolean;
            emit(event: \\"resume\\"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;

            on(event: \\"close\\", listener: () => void): this;
            on(event: \\"data\\", listener: (chunk: any) => void): this;
            on(event: \\"end\\", listener: () => void): this;
            on(event: \\"error\\", listener: (err: Error) => void): this;
            on(event: \\"pause\\", listener: () => void): this;
            on(event: \\"readable\\", listener: () => void): this;
            on(event: \\"resume\\", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;

            once(event: \\"close\\", listener: () => void): this;
            once(event: \\"data\\", listener: (chunk: any) => void): this;
            once(event: \\"end\\", listener: () => void): this;
            once(event: \\"error\\", listener: (err: Error) => void): this;
            once(event: \\"pause\\", listener: () => void): this;
            once(event: \\"readable\\", listener: () => void): this;
            once(event: \\"resume\\", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;

            prependListener(event: \\"close\\", listener: () => void): this;
            prependListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependListener(event: \\"end\\", listener: () => void): this;
            prependListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependListener(event: \\"pause\\", listener: () => void): this;
            prependListener(event: \\"readable\\", listener: () => void): this;
            prependListener(event: \\"resume\\", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;

            prependOnceListener(event: \\"close\\", listener: () => void): this;
            prependOnceListener(event: \\"data\\", listener: (chunk: any) => void): this;
            prependOnceListener(event: \\"end\\", listener: () => void): this;
            prependOnceListener(event: \\"error\\", listener: (err: Error) => void): this;
            prependOnceListener(event: \\"pause\\", listener: () => void): this;
            prependOnceListener(event: \\"readable\\", listener: () => void): this;
            prependOnceListener(event: \\"resume\\", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;

            removeListener(event: \\"close\\", listener: () => void): this;
            removeListener(event: \\"data\\", listener: (chunk: any) => void): this;
            removeListener(event: \\"end\\", listener: () => void): this;
            removeListener(event: \\"error\\", listener: (err: Error) => void): this;
            removeListener(event: \\"pause\\", listener: () => void): this;
            removeListener(event: \\"readable\\", listener: () => void): this;
            removeListener(event: \\"resume\\", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;

            [Symbol.asyncIterator](): AsyncIterableIterator<any>;
        }",
                  "typeText": "Readable",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "cleanup",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "preferLocal",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "localDir",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "execPath",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "buffer",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdin",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "reject",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stripFinalNewline",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "extendEnv",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "cwd",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "env",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
              "nodeText": "interface ProcessEnv extends Dict<string> {}",
              "typeText": "ProcessEnv",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "argv0",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdio",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"pipe\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"ignore\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"inherit\\"",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "typeText": "readonly StdioOption[]",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "serialization",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"json\\" | \\"advanced\\"",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"json\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"advanced\\"",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "detached",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "uid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "gid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "shell",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | boolean",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "false",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "true",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "encoding",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "EncodingType",
              "nodeText": "EncodingType",
              "typeText": "EncodingType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "timeout",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "maxBuffer",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "killSignal",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | number",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "primitive",
                "type": "number",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsVerbatimArguments",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsHide",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface Options<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer | ReadableStream;
	}",
        "nodeText": "interface Options<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer | ReadableStream;
	}",
        "typeText": "Options<EncodingType>",
      },
      "tsdoc": null,
    },
    "(index).StdioOption": Object {
      "kind": "alias",
      "name": "StdioOption",
      "raw": Object {
        "nodeFullText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
        "nodeText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
        "typeText": "StdioOption",
      },
      "tsdoc": null,
      "type": Object {
        "discriminantProperties": null,
        "isDiscriminated": false,
        "kind": "union",
        "raw": Object {
          "nodeFullText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
          "nodeText": "type StdioOption =
		| 'pipe'
		| 'ipc'
		| 'ignore'
		| 'inherit'
		| Stream
		| number
		| undefined;",
          "typeText": "StdioOption",
        },
        "types": Array [
          Object {
            "kind": "primitive",
            "type": "number",
          },
          Object {
            "base": "string",
            "kind": "literal",
            "name": "\\"pipe\\"",
          },
          Object {
            "base": "string",
            "kind": "literal",
            "name": "\\"ipc\\"",
          },
          Object {
            "base": "string",
            "kind": "literal",
            "name": "\\"ignore\\"",
          },
          Object {
            "base": "string",
            "kind": "literal",
            "name": "\\"inherit\\"",
          },
          Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "class Stream extends internal {
            constructor(opts?: ReadableOptions);
        }",
              "nodeText": "class Stream extends internal {
            constructor(opts?: ReadableOptions);
        }",
              "typeText": "Stream",
            },
          },
        ],
      },
    },
    "(index).SyncOptions<EncodingType>": Object {
      "kind": "interface",
      "name": "SyncOptions",
      "props": Array [
        Object {
          "kind": "prop",
          "name": "input",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | Buffer",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/**
 * Raw data is stored in instances of the Buffer class.
 * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
 * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
 */
declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                  "nodeText": "declare class Buffer extends Uint8Array {
    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     * @deprecated since v10.0.0 - Use \`Buffer.from(string[, encoding])\` instead.
     */
    constructor(str: string, encoding?: BufferEncoding);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @deprecated since v10.0.0 - Use \`Buffer.alloc()\` instead (also see \`Buffer.allocUnsafe()\`).
     */
    constructor(size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}/{SharedArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     * @deprecated since v10.0.0 - Use \`Buffer.from(arrayBuffer[, byteOffset[, length]])\` instead.
     */
    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     * @deprecated since v10.0.0 - Use \`Buffer.from(array)\` instead.
     */
    constructor(array: ReadonlyArray<any>);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     * @deprecated since v10.0.0 - Use \`Buffer.from(buffer)\` instead.
     */
    constructor(buffer: Buffer);
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
     */
    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param data data to create a new Buffer
     */
    static from(data: ReadonlyArray<number>): Buffer;
    static from(data: Uint8Array): Buffer;
    /**
     * Creates a new buffer containing the coerced value of an object
     * A \`TypeError\` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for \`Buffer.from()\` variants.
     * @param obj An object supporting \`Symbol.toPrimitive\` or \`valueOf()\`.
     */
    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     */
    static from(str: string, encoding?: BufferEncoding): Buffer;
    /**
     * Creates a new Buffer using the passed {data}
     * @param values to create a new Buffer
     */
    static of(...items: number[]): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): encoding is BufferEncoding;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(
        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
        encoding?: BufferEncoding
    ): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: ReadonlyArray<Uint8Array>, totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Uint8Array, buf2: Uint8Array): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
    /**
     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.
     */
    static poolSize: number;

    write(string: string, encoding?: BufferEncoding): number;
    write(string: string, offset: number, encoding?: BufferEncoding): number;
    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
    toString(encoding?: BufferEncoding, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer'; data: number[] };
    equals(otherBuffer: Uint8Array): boolean;
    compare(
        otherBuffer: Uint8Array,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number
    ): number;
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is incompatible with \`Uint8Array#slice()\`, which returns a copy of the original memory.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    slice(begin?: number, end?: number): Buffer;
    /**
     * Returns a new \`Buffer\` that references **the same memory as the original**, but offset and cropped by the start and end indices.
     *
     * This method is compatible with \`Uint8Array#subarray()\`.
     *
     * @param begin Where the new \`Buffer\` will start. Default: \`0\`.
     * @param end Where the new \`Buffer\` will end (not inclusive). Default: \`buf.length\`.
     */
    subarray(begin?: number, end?: number): Buffer;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
    writeUIntLE(value: number, offset: number, byteLength: number): number;
    writeUIntBE(value: number, offset: number, byteLength: number): number;
    writeIntLE(value: number, offset: number, byteLength: number): number;
    writeIntBE(value: number, offset: number, byteLength: number): number;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readUIntLE(offset: number, byteLength: number): number;
    readUIntBE(offset: number, byteLength: number): number;
    readIntLE(offset: number, byteLength: number): number;
    readIntBE(offset: number, byteLength: number): number;
    readUInt8(offset?: number): number;
    readUInt16LE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readUInt32LE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt8(offset?: number): number;
    readInt16LE(offset?: number): number;
    readInt16BE(offset?: number): number;
    readInt32LE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readFloatLE(offset?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleLE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset?: number): number;
    writeUInt16LE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeUInt32LE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt8(value: number, offset?: number): number;
    writeInt16LE(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeInt32LE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeFloatLE(value: number, offset?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleLE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;

    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;

    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
    entries(): IterableIterator<[number, number]>;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}",
                  "typeText": "Buffer",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "cleanup",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "preferLocal",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "localDir",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "execPath",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "buffer",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdin",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdout",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "stderr",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(index).StdioOption",
          },
        },
        Object {
          "kind": "prop",
          "name": "reject",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "all",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "stripFinalNewline",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "extendEnv",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "cwd",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "env",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "// Alias for compatibility
            interface ProcessEnv extends Dict<string> {}",
              "nodeText": "interface ProcessEnv extends Dict<string> {}",
              "typeText": "ProcessEnv",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "argv0",
          "type": Object {
            "kind": "primitive",
            "type": "string",
          },
        },
        Object {
          "kind": "prop",
          "name": "stdio",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"pipe\\" | \\"ignore\\" | \\"inherit\\" | readonly StdioOption[]",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"pipe\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"ignore\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"inherit\\"",
              },
              Object {
                "kind": "unsupported",
                "raw": Object {
                  "nodeFullText": "/////////////////////////////
/// ECMAScript Array API (specially handled by compiler)
/////////////////////////////

interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "nodeText": "interface ReadonlyArray<T> {
    /**
     * Gets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    readonly length: number;
    /**
     * Returns a string representation of an array.
     */
    toString(): string;
    /**
     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
     */
    toLocaleString(): string;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: ConcatArray<T>[]): T[];
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function.
     * If thisArg is omitted, undefined is used as the this value.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;

    readonly [n: number]: T;
}",
                  "typeText": "readonly StdioOption[]",
                },
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "serialization",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "\\"json\\" | \\"advanced\\"",
            },
            "types": Array [
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"json\\"",
              },
              Object {
                "base": "string",
                "kind": "literal",
                "name": "\\"advanced\\"",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "detached",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "uid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "gid",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "shell",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | boolean",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "false",
              },
              Object {
                "base": "boolean",
                "kind": "literal",
                "name": "true",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "encoding",
          "type": Object {
            "kind": "unsupported",
            "raw": Object {
              "nodeFullText": "EncodingType",
              "nodeText": "EncodingType",
              "typeText": "EncodingType",
            },
          },
        },
        Object {
          "kind": "prop",
          "name": "timeout",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "maxBuffer",
          "type": Object {
            "kind": "primitive",
            "type": "number",
          },
        },
        Object {
          "kind": "prop",
          "name": "killSignal",
          "type": Object {
            "discriminantProperties": null,
            "isDiscriminated": false,
            "kind": "union",
            "raw": Object {
              "nodeFullText": "",
              "nodeText": "",
              "typeText": "string | number",
            },
            "types": Array [
              Object {
                "kind": "primitive",
                "type": "string",
              },
              Object {
                "kind": "primitive",
                "type": "number",
              },
            ],
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsVerbatimArguments",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
        Object {
          "kind": "prop",
          "name": "windowsHide",
          "type": Object {
            "kind": "primitive",
            "type": "boolean",
          },
        },
      ],
      "raw": Object {
        "nodeFullText": "interface SyncOptions<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer;
	}",
        "nodeText": "interface SyncOptions<EncodingType = string> extends CommonOptions<EncodingType> {
		/**
		Write some input to the \`stdin\` of your binary.
		*/
		readonly input?: string | Buffer;
	}",
        "typeText": "SyncOptions<EncodingType>",
      },
      "tsdoc": null,
    },
  },
}
`;

exports[`can get EDD from "sponsorsme" package 1`] = `
Object {
  "modules": Array [
    Object {
      "isMain": false,
      "kind": "module",
      "location": Object {
        "filePath": "dist/index.d.ts",
      },
      "mainExport": Object {
        "kind": "object",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "token",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
          Object {
            "kind": "prop",
            "name": "options",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
          Object {
            "kind": "prop",
            "name": "cached",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
          Object {
            "kind": "prop",
            "name": "cursor",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
          Object {
            "kind": "prop",
            "name": "hasNextPage",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
          Object {
            "kind": "prop",
            "name": "getInfo",
            "type": Object {
              "hasProps": false,
              "isOverloaded": false,
              "kind": "callable",
              "props": Array [],
              "raw": Object {
                "nodeFullText": "/**
     * Returns information about the sponsor if it exists.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.getInfo(\\"maticzav\\")
     * \`\`\`
     */
    getInfo(login: string): Promise<Optional<Sponsorship>>;",
                "nodeText": "getInfo(login: string): Promise<Optional<Sponsorship>>;",
                "typeText": "(login: string) => Promise<Sponsorship>",
              },
              "sigs": Array [
                Object {
                  "kind": "sig",
                  "params": Array [
                    Object {
                      "kind": "sigParam",
                      "name": "login",
                      "type": Object {
                        "kind": "primitive",
                        "type": "string",
                      },
                    },
                  ],
                  "return": Object {
                    "kind": "unsupported",
                    "raw": Object {
                      "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                      "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                      "typeText": "Promise<Sponsorship>",
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "isSponsor",
            "type": Object {
              "hasProps": false,
              "isOverloaded": false,
              "kind": "callable",
              "props": Array [],
              "raw": Object {
                "nodeFullText": "/**
     * Tells whether there exists a sponsor with the given login.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.isSponsor(\\"maticzav\\")
     * \`\`\`
     */
    isSponsor(login: string): Promise<boolean>;",
                "nodeText": "isSponsor(login: string): Promise<boolean>;",
                "typeText": "(login: string) => Promise<boolean>",
              },
              "sigs": Array [
                Object {
                  "kind": "sig",
                  "params": Array [
                    Object {
                      "kind": "sigParam",
                      "name": "login",
                      "type": Object {
                        "kind": "primitive",
                        "type": "string",
                      },
                    },
                  ],
                  "return": Object {
                    "kind": "unsupported",
                    "raw": Object {
                      "nodeFullText": "/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                      "nodeText": "interface Promise<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}",
                      "typeText": "Promise<boolean>",
                    },
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "flush",
            "type": Object {
              "hasProps": false,
              "isOverloaded": false,
              "kind": "callable",
              "props": Array [],
              "raw": Object {
                "nodeFullText": "/**
     * Clears the cache.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * sponsors.flush()
     * \`\`\`
     */
    flush(): void;",
                "nodeText": "flush(): void;",
                "typeText": "() => void",
              },
              "sigs": Array [
                Object {
                  "kind": "sig",
                  "params": Array [],
                  "return": Object {
                    "kind": "primitive",
                    "type": "void",
                  },
                },
              ],
            },
          },
          Object {
            "kind": "prop",
            "name": "find",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
          Object {
            "kind": "prop",
            "name": "sponsorshipFromEdge",
            "type": Object {
              "kind": "primitive",
              "type": "any",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "/**
 * # sponsorme
 *
 * A lightweight client that lets you check your GitHub sponsors.
 *
 * ## Installation
 *
 * \`\`\`bash
 * yarn add sponsorme
 * \`\`\`
 *
 * ## Example
 *
 * \`\`\`ts
 * let sponsors = Sponsors({ token: \\"token\\" })
 *
 * await sponsors.getInfo(\\"maticzav\\")
 * \`\`\`
 *
 * That's it!
 */
/**
 * Creates a Sponsors client that you can use to get sponsors information.
 */
export default class Sponsors {
    private token;
    private options;
    private cached;
    private cursor;
    private hasNextPage;
    constructor(opts: SponsorsOptions);
    /**
     * Returns information about the sponsor if it exists.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.getInfo(\\"maticzav\\")
     * \`\`\`
     */
    getInfo(login: string): Promise<Optional<Sponsorship>>;
    /**
     * Tells whether there exists a sponsor with the given login.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.isSponsor(\\"maticzav\\")
     * \`\`\`
     */
    isSponsor(login: string): Promise<boolean>;
    /**
     * Clears the cache.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * sponsors.flush()
     * \`\`\`
     */
    flush(): void;
    /**
     * Internal helper that finds a sponsoring for a given login.
     */
    private find;
    /**
     * Converts response's edge to Sponsorship abstract type.
     */
    private sponsorshipFromEdge;
    private static query;
}",
          "nodeText": "export default class Sponsors {
    private token;
    private options;
    private cached;
    private cursor;
    private hasNextPage;
    constructor(opts: SponsorsOptions);
    /**
     * Returns information about the sponsor if it exists.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.getInfo(\\"maticzav\\")
     * \`\`\`
     */
    getInfo(login: string): Promise<Optional<Sponsorship>>;
    /**
     * Tells whether there exists a sponsor with the given login.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * await sponsors.isSponsor(\\"maticzav\\")
     * \`\`\`
     */
    isSponsor(login: string): Promise<boolean>;
    /**
     * Clears the cache.
     *
     * \`\`\`ts
     * let sponsors = Sponsors({ token: \\"token\\" })
     * sponsors.flush()
     * \`\`\`
     */
    flush(): void;
    /**
     * Internal helper that finds a sponsoring for a given login.
     */
    private find;
    /**
     * Converts response's edge to Sponsorship abstract type.
     */
    private sponsorshipFromEdge;
    private static query;
}",
          "typeText": "Sponsors",
        },
      },
      "name": "index",
      "namedExports": Array [
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "SponsorsOptions",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(dist/index).SponsorsOptions",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "Sponsorship",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(dist/index).Sponsorship",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "SponsorshipSponsor",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(dist/index).SponsorshipSponsor",
          },
        },
        Object {
          "isTerm": false,
          "isType": true,
          "kind": "export",
          "name": "SponsorshipTier",
          "type": Object {
            "kind": "typeIndexRef",
            "link": "(dist/index).SponsorshipTier",
          },
        },
      ],
      "path": "/dist/index",
      "tsdoc": null,
    },
  ],
  "typeIndex": Object {
    "(dist/index).SponsorsOptions": Object {
      "kind": "alias",
      "name": "SponsorsOptions",
      "raw": Object {
        "nodeFullText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
        "nodeText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
        "typeText": "SponsorsOptions",
      },
      "tsdoc": null,
      "type": Object {
        "kind": "object",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "cache",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "token",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
          "nodeText": "export declare type SponsorsOptions = {
    /**
     * Whether the client should use internal cache or not.
     */
    cache?: boolean;
    /**
     * Viewer's GitHub token used for authentication.
     */
    token: string;
};",
          "typeText": "SponsorsOptions",
        },
      },
    },
    "(dist/index).Sponsorship": Object {
      "kind": "alias",
      "name": "Sponsorship",
      "raw": Object {
        "nodeFullText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
        "nodeText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
        "typeText": "Sponsorship",
      },
      "tsdoc": null,
      "type": Object {
        "kind": "object",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "id",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "createdAt",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "sponsor",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(dist/index).SponsorshipSponsor",
            },
          },
          Object {
            "kind": "prop",
            "name": "public",
            "type": Object {
              "kind": "primitive",
              "type": "boolean",
            },
          },
          Object {
            "kind": "prop",
            "name": "tier",
            "type": Object {
              "kind": "typeIndexRef",
              "link": "(dist/index).SponsorshipTier",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
          "nodeText": "export declare type Sponsorship = {
    id: string;
    createdAt: string;
    /**
     * Sponsor information.
     */
    sponsor: SponsorshipSponsor;
    /**
     * Whether sponsorship is publicly visible.
     */
    public: boolean;
    /**
     * Information about the tier.
     */
    tier: SponsorshipTier;
};",
          "typeText": "Sponsorship",
        },
      },
    },
    "(dist/index).SponsorshipSponsor": Object {
      "kind": "alias",
      "name": "SponsorshipSponsor",
      "raw": Object {
        "nodeFullText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
        "nodeText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
        "typeText": "SponsorshipSponsor",
      },
      "tsdoc": null,
      "type": Object {
        "kind": "object",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "login",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "email",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
          "nodeText": "export declare type SponsorshipSponsor = {
    /**
     * Login handle of the sponsor.
     */
    login: string;
    /**
     * Sponsor's email if available.
     */
    email?: string;
};",
          "typeText": "SponsorshipSponsor",
        },
      },
    },
    "(dist/index).SponsorshipTier": Object {
      "kind": "alias",
      "name": "SponsorshipTier",
      "raw": Object {
        "nodeFullText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
        "nodeText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
        "typeText": "SponsorshipTier",
      },
      "tsdoc": null,
      "type": Object {
        "kind": "object",
        "props": Array [
          Object {
            "kind": "prop",
            "name": "id",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "createdAt",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "name",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "description",
            "type": Object {
              "kind": "primitive",
              "type": "string",
            },
          },
          Object {
            "kind": "prop",
            "name": "monthlyPriceInCents",
            "type": Object {
              "kind": "primitive",
              "type": "number",
            },
          },
        ],
        "raw": Object {
          "nodeFullText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
          "nodeText": "export declare type SponsorshipTier = {
    id: string;
    createdAt: string;
    /**
     * Information about the tier.
     */
    name: string;
    description: string;
    /**
     * The amount sponsoree receives each month.
     */
    monthlyPriceInCents: number;
};",
          "typeText": "SponsorshipTier",
        },
      },
    },
  },
}
`;
